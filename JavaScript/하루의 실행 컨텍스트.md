<img src='./images/하루의 실행 컨텍스트/스크린샷 2023-01-02-1.png'>

- 오늘 발표에서는 실행 컨텍스트 안에 있는 레코드와 아우터 이렇게 간단하게 발표할 예정입니다

- 그래서 발표 목차는 첫째 레코드를 통해 자바스크립트의 호이스팅 을 이해하고

- 둘째 아우터를 통해 자바스크립트의 스코프에 대해 이해한 후에

- 마지막으로 실행 컨텍스트에 대해 정리하고 마무리 하겠습니다

<br/>

<img src='./images/하루의 실행 컨텍스트/스크린샷 2023-01-02-2.png'>

- 자바스크립트 코드를 실행시키면 자바스크립트 엔진은 콜 스택이라는 통에 전역 실행 컨텍스트를 담습니다

- 실행 컨텍스트니까 안에 아까 봤던 레코드와 아우터가 담겨 있죠

- 만약 전역에서 함수 얘기를 호출할 경우 함수 a 라는 실행 컨텍스트를 생성해서 또 콜 스택 에 담아요

- 콜 스택에서는 가장 최근에 추가된 실행 컨텍스트만 활성화 됩니다

- 그러니까 위에서 내려다 봤을 때 실행 되고 있는 실행컨텍스트 활성화 된 실행 콘텍스트이고 현재 활성화된 컨텍스트는 함수 a의 실행 컨텍스트네요

- 만약 함수 a에서 함수 b 가 호출되면 또 실행 컨텍스트를 담습니다 함수 b의 실행을 마치고 함수 b가 종료되면 실행 컨텍스트가 사라집니다

- 그러면 함수에 a로 돌아올 수 있겠죠

- 이어서 함수 a가 종료되면 이 실행 컨텍스트도 사라집니다

- 전역에 있는 코드가 마지막 라인까지 모두 실행되면 전역에 있는 컨텐츠도 사라집니다.

<br/>

## 1장 레코드로 호스팅 이해하기

### 변수 호이스팅

<img src='./images/하루의 실행 컨텍스트/스크린샷 2023-01-02-3.png'>

- var 키워드로 TVChallenl이 라는 변수를 선언하고 내 Netflix 를 할당 했을 때 선언 이후에 TVChannel의 값을 출력해 보면 예상한 것과 같이 일해 Netflix가 출력됩니다.

- 위처럼 출력해 보면 어떨까요

- 다른 언어에서는 에러가 날 수 있겠지만 자바스크립트 에서는 에러가 발생하지 않고 undefiend가 출력됩니다

- TVChannel이 첫 번째 콘솔로 그 전에 이미 만들어진 것 같죠

- 이렇게 선언 이 전에도 에러가 나지 않고 변수를 참조조할 수 있는 현상을 선언문이 마치 최상단에 끌어 올려진 듯하다고 해서 호스팅 현상 이라고 부르는데요

- 이 현상이 발생하는 이유는 선언문 있는 코드 라인을 물리적으로 채 종단의 끌어 올렸기 때문이 아니라, 자바스크립트 엔진이 먼저 전체 코드를 스캔하면서 변수 같은 정보를 실행 컨텍스트 어딘가에 미리 기록해놓기 때문입니다

<img src='./images/하루의 실행 컨텍스트/스크린샷 2023-01-02-4.png'>

- 이때 기록해 놓는 것이 바로 이 노란색 동그라미 레코드 입니다

- 에크마스크립트 나오는 정식 명칭은 환경 레코드로 식별자와 식별자에 바인딩 된 값을 기록해 두는 객체입니다

- 이 환경 레코드의 변수가 어떻게 저장되는지만 봐도 호스팅을 빠삭하게 이해할 수 있는데요

- 저희는 호스팅을 두 가지 종류로 나누어 변수 호이스팅과 함수 호이스팅 이 순서대로 살펴볼게요

<img src='./images/하루의 실행 컨텍스트/스크린샷 2023-01-02-5.png'>

- 자바스크립트 엔진은 코드를 실행하면 우선 전역 실행 컨텍스트에 한 칸을 생성해서 콜 스택에 넣어줍니다.

- 그 후 전체 코드를 스캔하면 선언할게 있는지 찾아보고 있다면 먼저 선언해 줍니다.

- 선언하는 과정에서 생성해 둔 실행 컨텍스트 안에 있는 환경 레코드의 새로운 식별자 TVChannel 채널을 기록해 둡니다

- 그리고 var 키워드로 선언했기 때문에 undefined 으로 값을 초기화 해줍니다

- 이렇게 본격적인 실행에 앞서 스캔하고 준비하는 단계를 생성 단계 라고 합니다

- 실행 컨텍스트를 생성하고 선언문만 먼저 실행해서 환경 레코드의 미리 기록해 두는 관계죠

- 그리고 이어서 선언문 외에 나머지 코드를 순차적으로 실행하는 데 이 단계를 실행 단계 라고 합니다

- 필요한 경우 생성 단계에서 환경 레코드의 기록해 둔 정보 를 참고하거나 업데이트를 하게 됩니다

- 아까 생성 단계 까지 마쳤죠, 이후 실행 단계를 마저 관찰해 보겠습니다

<img src='./images/하루의 실행 컨텍스트/스크린샷 2023-01-02-6.png'>

- 첫번째로 TVChannel의 값을 출력하는 console.log가 실행됩니다

- 출력하려면 TVChannel에 바인딩된 값이 먼지 알아야겠죠

- 자바스크립트 엔진은 현재 활성화된 실행 컨텍스트 내에 환경 레코드를 보고 이미 기록된 TVChannel의 값을 참조해서 문제없이 값을 출력합니다

- 사실은 콘솔로그도 함수기 때문에 호출하면 이 함수의 실행 컨텍스트가 생기는 게 맞지만 이번 발표에서는 표현의 편의를 위해 간소화 에서 표현할게요

- 콘솔로그는 깍두기 라고 생각해주세요

- 그리고 다음 라인을 실행하는데 선언하는 아까 생성 단계에서 이미 했읜, TVChannel = 'netflix'라인의 할당만 실행해줍니다.

- TVChannel에 채널의 바인딩된 값을 Netflix로 업데이트에서 이렇게 됩니다

<img src='./images/하루의 실행 컨텍스트/스크린샷 2023-01-02-7.png'>

- 이후 마지막 라인 을 실행하면 자바스크립트 엔진은 역시 환경 레코드를 참조에서 TVChannel을 값을 netflix로 결정해서 출력해준다

- 만약 var 키워드 대신에 ES6 에서 추가된 const 키워드로 변수를 선언하면 어떻게 달라질까요

- 이 경우에는 엔진이 TVChannel 식별자를 기록해 두기는 하지만 값을 초기화 하지는 않습니다

- 따라서 선언문이 전에 TVChannel을 참조하려고 하면 레퍼런스 에러가 발생합니다

<img src='./images/하루의 실행 컨텍스트/스크린샷 2023-01-02-8.png'>

- 자바스크립트 엔진이 아직 TVChannel의 값을 읽어 올 수 없었던 것이죠

<img src='./images/하루의 실행 컨텍스트/스크린샷 2023-01-02-9.png'>

- 이렇게 let이 나 const로 선언한 경우에는 선언 라인 이전에 식별자를 참조할 수 없는데 이 구역을 일시적 사각지대 라고 부릅니다

- var 키워드로 변수를 선언한 경우에는 선언과 초기화가 동시에 이루어집니다

<img src='./images/하루의 실행 컨텍스트/스크린샷 2023-01-02-10.png'>

- [MDN - 자바스크립트의 메모리 관리](https://developer.mozilla.org/ko/docs/Web/JavaScript/Memory_Management)

  - In order to not bother the programmer with allocations, JavaScript will automatically allocate memory when values are initially declared.

  - 프로그래머를 할당 문제로 괴롭히지 않기 위해서, 자바스크립트는 값을 선언할 때 자동으로 메모리를 할당합니다.

- 선언 단계에서는 메모리 공간을 확보해 주고, 메모리 주소에 식별자를 연결해 줍니다

- 초기화 단계에서는 식별자를 암묵적으로 undefined 값으로 초기화 됩니다

- 반면 변수를 let, const 키워드로 선언하면 값을 undefined 으로 초기화 해 두지 않습니다

- 그럼 자연스럽게 할당 직전까지는 변수에 아무런 값이 남기지 않고 그럼 유효한 값을 읽어올 수도 없겠죠

- 이러한 동작 때문에 일시적 사각지대가 생기는 것입니다

- 이렇게 var 키워드와 다르게 동작하는 let, const 키워드가 비교적 최근에 추가되었다는 건 자바스크립트 에서도 선언 라인 이전에는 변수를 참조할 수 없다는 일반적인 프로그래밍 방식을 추가할 수 있도록 언어 차원에서 보안 되었다 라고도 볼 수 있을것 같아요

<br/>

### 함수 호이스팅

- 함수 호이스팅을 살펴보겠습니다

- 자바스크립트에서는 함수를 변수에 다가 담을 수 있는데요 (함수 표현식)

<img src='./images/하루의 실행 컨텍스트/스크린샷 2023-01-02-11.png'>

- var 키워드의 화살표 함수를 var 선언문 이전에 실행하려고 하면 환경 레코드의 기록되어 있는 스터디에 값은 undefined 이고 undefined 라는 데이터 타입은 함수와 달리 호출될 수 없기 때문에 타입 에러가 발생합니다

- 같은 향수를 const 키워드 로 선언하면 아직 환경 레코드의 기억된 값이 없어 왜 레퍼런스 에러 가 발생합니다

<img src='./images/하루의 실행 컨텍스트/스크린샷 2023-01-02-12.png'>

- 이렇게 변수에 함수를 담아서 함수를 선언 하는 방식을 함수 표현식 이라고 하는데 함수를 변수에 담고 있기 때문에 앞서 살펴본 변수 호이스팅과 똑같이 동작합니다

<img src='./images/하루의 실행 컨텍스트/스크린샷 2023-01-02-13.png'>

- 이번에는 함수를 변수에 담지 않고 function 워드로 선언해 보겠습니다

- 함수 선언문 방식으로 함수를 선언하는 경우에는 자바스크립트 엔진이 study 함수의 선언과 동시에 완성된 함수 객체를 생성해서 환경 레코드의 기록해 둡니다

<img src='./images/하루의 실행 컨텍스트/스크린샷 2023-01-02-14.png'>

- 그리고 스터디 함수를 실행하면 드디어 스터디 함수가 에러 없이 실행 되었습니다

- 이렇게 변수에 닮지 않고 함수 선언문 방식 으로 선언한 함수의 경우에는 사람과 동시에 함수가 생성된다 않은 점이 큰 특징이에요

<img src='./images/하루의 실행 컨텍스트/스크린샷 2023-01-02-15.png'>

- 참고로 이 방식을 사용하면 선언전에도 함수를 사용할 수 있게 되서 사용을 지양하고자 하는 목소리도 있습니다

- 함수 표현식 함수 선언문 두 경우에 환경 레코드를 살펴보면 두가지의 차이점을 잘 정리해 둘 수 있을 것 같아요

<img src='./images/하루의 실행 컨텍스트/스크린샷 2023-01-02-16.png'>

- 함수 표현식은 var 키워드 일때는 환경 레코드의 값을 undefined 초기화해두는데 undefined를 호출 하려고 해서 타입 에러가 났었고

- let const 일때는 환경 레코드에 각질 초기화 해두지 않아서 참조 하려니까 레퍼런스 에러가 낫었죠

- 함수 선언문은 선언과 동시에 함수 생성을 마치고 온전하게 환경 레코드에 저장해 두기 때문에 선언 라인 이전 전에도 함수를 호출할 수 있었어요

<img src='./images/하루의 실행 컨텍스트/스크린샷 2023-01-02-17.png'>

---

<br/>

## 2장 아우터로 JS 스코프 체인 이해하기

<img src='./images/하루의 실행 컨텍스트/스크린샷 2023-01-02-18.png'>

- 동그라미 아우터의 정체를 알아 봅시다

- 아우터의 정식 명칭은 외부환경 참조입니다

- 바깥 Lexical Environment 가리키는데

<img src='./images/하루의 실행 컨텍스트/스크린샷 2023-01-02-19.png'>

- 저희가 단순화한 요 실행 컨텍스트에서 이 두 동그라미를 합쳐서 Lexical Environment 하고 렉시컬 환경 또는 정적 환경 이라고도 불러요

- 이번에는 램프를 선언하고 그 값을 출력하는 코드 가 있네요

<img src='./images/하루의 실행 컨텍스트/스크린샷 2023-01-02-20.png'>

- 실행 컨텍스트의 환경 레코드에 이렇게 램프 홀수로 저장되어 있을 텐데 이번 장에서는 이걸 이렇게 불이 꺼진 램프 그림으로 추상화해서 표현 할게요

- 자바스크립트 엔진은 현재 활성화 된 실행 컨텍스트의 환경레코드를 보고 램프의 값을 쉽게 결정해 됩니다

- 이번에는 코드를 조금 추가해서 goTo2F 이라는 함수를 선언 해볼게요

- 함수 선언문 방식이라 선언하는 동시에 환경 레코드에 생성된 함수가 통째로 기록 될 테고 이 함수를 실행하면 새로운 실행 컨텍스트 가 생성됩니다

- 매개 변수가 있다면 그것도 환경 레코드의 기록 하겠지만 없으니 넘어가서 램프를 기록합니다

- 그리고 램프에 값을 출력하려고 환경에 코드를 보니 불이 꺼진 램프와 불이 켜진 램프 두개가 있네요

- 자바스크립트 엔진은 과연 램프에 값을 둘 중 무엇으로 결정해야 하나 고민에 빠집니다

- 이런 상황에서 변수나 함수의 값을 결정해 내는 것을 식별자 결정 이라고 합니다

- 1장 에서도 자바스크립트 엔진이 어떤 식별자의 값을 결정하는 일을 반복하고 있다는 걸 느끼셨을 거에요

<img src='./images/하루의 실행 컨텍스트/스크린샷 2023-01-02-21.png'>

- 식별자 결정은 사실 오늘 발표해서 제일 중요한 키워드 이기도 합니다

- 콜 스택 안에 동일한 식별자가 여럿일 때 자바스크립트 엔진이 어떻게 아우터를 활용해서 의사결정을 하는지 알아보겠습니다

- 다시 goTo2F 함수가 호출되는 시점으로 돌아가 볼게요

- 함수의 실행 컨텍스트를 새로 생성하고 이 때 자바스크립트 엔진은 새로 생성된 실행 컨텍스트에 바깥 레시컬 환경으로 돌아갈 수 있는 아우터를 남겨 놓습니다

<img src='./images/하루의 실행 컨텍스트/스크린샷 2023-01-02-22.png'>

- 이제 필요한 경우 이전 실행 컨텍스트의 환경 레코드에 저장된 식별자도 참조조할 수 있게 되었어요

- 이어서 goTo2F 함수가 실행됩니다

- 램프를 기록하고 함수도 추가 해 볼게요 그러면 goTo3F 함수가 기록되고 goTo3F 함수 안에서 다시 goTo2F 함수가 호출됩니다

- 함수가 호출되었으니 또 실행 컨텍스트가 새로 생성되고 이전 렉시컬 환경을 가리키는 아우터를 현재 실행 컨텍스트에 저장합니다

- goTo3F 함수를 실행합니다 상층에서는 pet에 puppy를 할당합니다

- 그리고 Pet의 값을 출력하려고 하면 자바스크립트 엔진은 pet 값을 결정하기 위해 환경 레코드를 봅니다

- 콜 스택을 통틀어서 Pet이 하나 밖에 없긴 하지만 원칙적으로 현재 활성화된 실행 컨텍스트의 환경 레코드를 먼저 봅니다

- pet의 값이 puppy 니까 자바스크립트 엔진은 puppy를 잘 출력해 됩니다

- 그럼 만약 코로나를 출력하려고 하면 어떻게 될까요

- 현재 활성화된 실행 컨텍스트의 환경레코드를 봐도 코로나는 없습니다

- 그럼 자바스크립트 엔진은 아우터가 가리키는 바깥 렉시컬 환경으로 가서 코로나를 찾기 시작합니다

- 역시 크로나가 없죠 그러면 또 아우터를 타고 바깥 렉시컬 환경으로 갑니다

- 역시 여기에도 코로나는 없네요

- 서 전역 실험 컨텍스트에 렉시컬 환경까지 와 버렸는데요 전역 실행 컨텍스트는 더 바깥이랄게 없는 최상위 실행 컨텍스트 이기 때문에 자바스크립트 엔진은 코로나를 찾는 것을 멈추고 코로나는 없다는 결론을 내립니다

- 그리고 없는 식별자를 참조하고 있기 때문에 레퍼런스 에러를 출력합니다.

<img src='./images/하루의 실행 컨텍스트/스크린샷 2023-01-02-23.png'>

- 마지막으로 아까 출력하려고 했던 램프만 출력해 보고 이번 장을 마무리하려고 합니다

- 현재 활성화 된 실행 컨텍스트에는 램프가 없어서 아우터와 가리키는 바깥 렉시컬 환경으로 가서 다시 램프를 찾게 됩니다

- 그리고 켜져 있는 램프를 찾아서 값을 on으로 출력해 내는 데요

- 여기서 주목할 점은 2층에서 이미 램프를 찾았기 때문에 더 이상 1층으로 내려가서 찾아보지 않는 다는 점입니다

- 2층에 램프와 1층에 램프가 같은 이름이기 때문에 즉 식별자 같기 때문에 1층의 램프가 켜져 있는지 꺼져 있는지는 2층에서도 3층에서 도 절대 알 수가 없습니다

- 이렇게 동일한 식별자로 인해 상위이 스코프 에서 선언된 식별자 의 값이 가려지는 현상을 변수 쉐도잉 이라고 합니다

<img src='./images/하루의 실행 컨텍스트/스크린샷 2023-01-02-24.png'>

- 지금까지 충 층이 쓰인 컨텍스트가 사용했을 때 어떻게 식별자를 결정하는 지 살펴 봤어요

- 현재 활성화된 실행 컨텍스트는 하나 이지만 이전 렉시컬 환경을 가리키는 아우터로 타고 타고 갈 수 있기 때문에 3층에 없으면 2층으로 가서 찾고고 2층에 없으면 1층으로 가서 찾을 수 있었습니다

<img src='./images/하루의 실행 컨텍스트/스크린샷 2023-01-02-25.png'>

- 이렇게 식별자를 결정할 때 활용하는 스코프 들의 연결 리스트를 스코프 체인 이라고 하고, 식별자를 결정하기 위해 타고 타고 가서 찾는 과정 자체를 스코프 체이닝 이라고 합니다

- 이 장에서는 많은 키우는 없었지만 정말 중요요한 식별자 결정과 스코프체인이라는 키워드가 있었습니다

<br/>

## 3장 실행 컨텍스트 정리

- 실행 컨텍스트를 한마디로 뭐라고 정리할 수 있을까요

- 실행 컨텍스트는 한마디로 **코드**를 실행하는데 필요한 **환경**을 제공하는 객체 라고 할 수 있습니다

- 여기서 환경이란 코드를 실행에 영향을 주는 조건이나 상태를 의미하는데요

- 따라서 코드를 실행하는데 필요한 조건이나 상태를 모아둔 객체가 바로 실행 컨텍스트 인거죠

---

## Reference

- [10분 테코톡 - 하루의 실행 컨텍스트](https://www.youtube.com/watch?v=EWfujNzSUmw&t=25s)
