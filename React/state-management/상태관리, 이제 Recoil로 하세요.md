### Recoil의 핵심 컨셉

1. 오직 React 만을 위해 React 처럼

2. React 내부 상태만 이용

3. 작은 Atom 단위로 관리

4. 순수함수 Selector

5. Re-Render 최소화

6. 데이터 흐름을 따라서

7. 곧 새로운 React 기능과 호환성

<br/>

- Recoil의 핵심 컨셉을 말씀드리면 React의 내부 상태만을 활용 한다는 점입니다

- 아주 작은 단위의 atom으로 관리되고 selector라는 순수함수를 제공합니다

- 상태가 변경이 되면 atom을 참조하는 컴포넌트만 리렌더링 되기 때문에 기존의 기술들만으로는 구현하기에 다소 복잡했던 부분들이 매우 쉽게 구현할 수 있게 되었습니다

- 또한 Recoil의 상태들은 상호의존성을 가질 수가 있는데요, 데이터 흐름에 따라서 여러 상태들의 연관된 컴포넌트들을 유기적으로 관리할 수 있습니다

- 장기적인 관점에서 보면 다른 서드 파티들은 하기 어려운 React의 향후 호환성 부분이나 자체 성능 향상을 통해서 얻을 수 있는 이점들에 대해서도 기대를 해 볼 수 있는 기술인 것 같습니다

<br/>

## 예제로 보는 Recoil 활용기 (Atom / Selector를 활용한 상품목록 만들기)

- 이제 예제 코드를 보면서 본격적으로 Recoil에 대한 사용법을 소개시켜 드리도록 하겠습니다

- 어떤 예제를 준비할까 하다가 저희 회사에서 개발한 서비스 중에 커머스 영역은 여러 사람들이 접하게 될 영역이라고 생각해서 간단한 상품 리스트를 만들어보면서 기본 활용법에 대해서 소개를 시켜 드리도록 하겠습니다

- 우선은 실제 데이터가 아니라 내부 상태만을 이용해서 기본적인 활용법들을 알아보겠습니다

<img src='./images/상태관리, 이제 Recoil로 하세요/1.jpg'>

- 코드를 보시기 전에 이 컴포넌트들과 상태들의 구조를 살펴보면 모달 팝업을 열고 닫는 기능은 아주 간단한 기능이지만

- 실제로 열고 닫는 이벤트가 각각 다른 컴포넌트에서 이루어져야 되기 때문에 상태 관리를 해야 되는 대표적인 예라고 할 수 있습니다

- 리스트 역시 여러 곳에서 향후 사용될 수 있기 때문에 상태 관리를 해 보도록 하겠습니다

<img src='./images/상태관리, 이제 Recoil로 하세요/2.jpg'>

- 코드를 보시면 상태를 정의하는 방법은 매우 간단한데요

- atom이라는 함수에 key와 기본값을 설정해줍니다

- 여기에 기본값은 초기에 비워놔도 되고 나중에 이 상태가 변경이 되었을 때 기존 타입과 무관하게 자유롭게 변경이 가능합니다

- 해당 atom을 호출 하는 방법은 React의 Hook 과 아주 유사한데요 Recoil에서 제공하는 state에 조금 전에 정의해둔 atom을 넣고 바로 Hook처럼 사용이 가능합니다

- 이렇게 간단하게 여러 컴포넌트에 걸쳐서 사용이 가능한 상태를 하나 구현해보았습니다

<img src='./images/상태관리, 이제 Recoil로 하세요/3.jpg'>

- 동일한 방식으로 리스트도 atom을 하나 만들어 주고 이 atom을 바로 호출해서 사용할 수 있는데

- Recoil에서는 특이하게 읽기 전용과 쓰기 전용 함수를 추가로 제공합니다 그 이유는 잠시 후에 설명 드리도록 하구요

<img src='./images/상태관리, 이제 Recoil로 하세요/4.jpg'>

- 먼저 등록 모달에서는 폼 데이터를 직접 리스트에 바로 추가하는 로직을 구현해 볼 겁니다

- 또한 조회나 수정을 위해서 product 데이터 한 건을 담을 수 있는 atom을 추가로 만들어 주었구요

- atom을 통해서 리스트에 있는 하나의 데이터를 찾아와서 담아올 겁니다

<img src='./images/상태관리, 이제 Recoil로 하세요/5.jpg'>

- 등록 모달을 보시면 폼 요소에 change event handler를 통해가지고 변경된 값을 내부 state에 담아서 리스트형 atom에 insert하는 로직입니다

- 여기서 폼 데이터는 특히 외부로 공유될 필요가 없기 때문에 굳이 Recoil를 사용하지 않았고요 단순히 Hook을 사용해서 내부 상태에 담아 가지고 바로 리스트에 담는 로직을 추가하였습니다

- 여기서 리스트와 팝업 상태는 set만 사용하기 때문에 아까 말씀드렸던 쓰기 전용 함수를 사용해 봤습니다

<img src='./images/상태관리, 이제 Recoil로 하세요/6.jpg'>

- 다음으로는 상세 정보 조회입니다

- 우선 상품을 담을 수 있는 atom을 정의해주었구요

- 그 다음에 리스트 컴포넌트에서 각 행을 클릭하게되면 이 인덱스 값을 내려받아서 리스트에 있는 데이터 중 이 인덱스 값과 매칭 되는 값을 가져와서 product atom에 담습니다

<img src='./images/상태관리, 이제 Recoil로 하세요/7.jpg'>

- 다시 모달 팝업으로 돌아와보면 앞에 담아온 product state를 불러와서 먼저 input에 초기값으로 설정을 해주고

- 이 product에 데이터가 있는지 여부에 따라서 이 모달 팝업이 등록 팝업인지, 수정 팝업인지 분기 처리를 해 줄 수 있게 됩니다

- 따라서 컴포넌트가 사라질 때 이 값을 초기화 해 줘야 되는데요

- 당연하게도 Recoil은 전역 상태이기 때문에 특정 값으로 변경 되지 않는 이상 이전 값을 유지하게 됩니다

- Recoil에서는 reset 함수를 추가로 제공을 해줍니다

- 그래서 이 useEffect를 통해서 이 컴포넌트가 언마운트 되는 시점에 값을 초기화 해 주지 않으면

- 향후 신규 등록 시 기존 데이터가 그대로 불러와지는 오류가 발생하게 됩니다

<br/>

<img src='./images/상태관리, 이제 Recoil로 하세요/8.jpg'>

- 다음으로는 필터링을 구현 해볼텐데요 이전의 atom 만으로는 필터링이라든지 정렬 같은 기능들을 구현하기에는살짝 부족한 점이 있습니다

- Recoil에서는 이 getter와 setter를 직접 정의해서 쓸 수 있는 selector 라는 순수함수 를 이용해 볼 건데요

- 이를 활용하면 상태를 읽고 쓸 때 데이터를 가공하거나 유효성 검사를 한다든지 부수적인 로직을 추가 할 수 있습니다

- 그리고 또 한 가지 특징으로는 selector 내부에서 다른 atom이나 다른 selector를 참조할 수 있는데요

- Recoil에서는 이것을 구독한다고 표현하고 있습니다

- 이렇게 구독이 되면 다른 데이터들에 대해서 의존성을 갖게 되는데 이 구독하고 있는 상태가 외부에서 변경이 되면

- 본 selector는 이를 감지하고 재평가 되어서 컴포넌트를 다시 렌더링 해주게 됩니다

  <img src='./images/상태관리, 이제 Recoil로 하세요/9.jpg'>

- seletor는 getter를 필수로 받고 있지만 setter를 선택적으로 정의할 수 있습니다

- 앞서 말했던 읽기 전용 과 쓰기 전용 함수가 제공되는 이유를 여기서 찾아볼 수가 있습니다

- 만약 getter만 정의된 selector를 사용한다고 했을 때 읽기, 쓰기 모두 가능한 Hook을 이용하려고 하면 발생되는 오류를 미연에 방지하기 위해서 이 함수를 구분해서 쓰라고 권고하고 있습니다

- 한 가지 팁으로 말씀드리면 이런 상태에 따라서 네이밍을 직관적으로 하게 되면 여러 사람이랑 협업을 할 때 실수를 조금이라도 줄일 수 있게 도움을 줄 것 같습니다

<img src='./images/상태관리, 이제 Recoil로 하세요/10.jpg'>

- 그럼 이제 필터링 부분을 구현해 볼 텐데요

- 필터 모달 용 atom과 필터가 저장되는 atom을 추가로 하나 만들어 주었구요

- 그리고 이 필터 값을 리스트에 반영하기 위해서 이전에 만들었던 리스트는 selector로 변경을 해 줄 겁니다

- 그리고 이 선택된 필터를 리스트에 적용해서 컴포넌트에 내려주는 로직으로 구현해 보겠습니다

<img src='./images/상태관리, 이제 Recoil로 하세요/11.jpg'>

- 좀 전에 필터를 열고 닫는 거나 필터를 저장하는 부분은 앞서 설명드린 로직과 크게 다르지 않아서 생략하고 필터링 된 리스트를 출력하는 코드를 보겠습니다

- 리스트는 기존에 필터를 만들어둔 것을 적용하기 위해서 구독을 하게 되는데 여기서 selector는 리스트와 필터의 영향을 받아서 필터가 변경되게 되면 해당 selector가 재평가 되게 됩니다

<br/>

## 비동기 데이터 다루기 (조금은 불편한 Recoil 비동기 데이터 쿼리)

- 다음으로는 비동기 데이터를 다루어 보겠습니다

- 여기까지는 너무 쉽게 Recoil을 사용해 봤는데요

- 하지만 지금까지의 내용으로는 실제 데이터를 다루기에는 좀 어려움이 있습니다

<img src='./images/상태관리, 이제 Recoil로 하세요/12.jpg'>

- 일단 서버 데이터를 한번 가져와 보겠습니다

- 이전에 만들어 놓은 리스트 selector를 비동기로 바꿔 볼 건데요

- 우선 getProductList()라는 실제 데이터를 가져오는 함수를 하나 추가해주었고 이 함수를 아까 만들었던 selector에서 getter에서 받아와 출력해 주는 로직입니다

- 단순히 앞에 async만 붙여 주면 기존처럼 동일하게 호출해서 사용할 수 있습니다

<img src='./images/상태관리, 이제 Recoil로 하세요/13.jpg'>

- 다음에는 상세 데이터도 한번 가져와 볼 건데요

- 초반 예제에는 내부 상태에서 값을 가져 오기 때문에 필요없었던 선택된 상품의 인덱스 값을 저장 할 수 있는 atom을 하나 추가해주었고 이 atom을 selector가 구독을 하게 할 겁니다

- 그렇게 되면 이 인덱스 값이 변경됨에 따라 서버에서 매번 다른 데이터를 가져올 수 있게 됩니다

<img src='./images/상태관리, 이제 Recoil로 하세요/14.jpg'>

- 여기서 프로덕트 인덱스를 selector에서 참조하게 되면 이 인덱스 값이 변경될 때마다 재평가 된다고 말씀드렸는데 또 다른 방법을 제공하고 있습니다

- Recoil에서는 selectorFamily라고 'family'가 붙어 있는 util을 제공하는데,

- 기존에 구독하고 있던 인덱스 값을 매개변수로 받을 수 있게 됩니다

- 여기서 두 개의 인덱스 는 동일한 의존성 효과를 갖게 됩니다

<img src='./images/상태관리, 이제 Recoil로 하세요/15.jpg'>

<br/>

- 근데 이렇게 구현된 코드를 실행해 보면 다음과 같은 오류를 볼 수 있는데요

- 비동기 RecoilState를 사용하게 되면 Suspense를 이용하라는 에러가 뜹니다

- 사용법은 간단하고 RecoilState를 사용하고 있는 컴포넌트들을 Suspense로 감싸주고 미리 만들었둔 indicator 컴포넌트 같은 거를 콜백에 내려 주면 바로 사용할 수 있습니다

- 만약에 이 Suspense를 사용하고 싶지 않으신 분들은 이 Loadable이라는 또 다른 기능을 이용할 수 있습니다

- 이 Loadable을 이용하면 각 상태에 따라서 관리를 해 줄 수가 있습니다

<br/>

<img src='./images/상태관리, 이제 Recoil로 하세요/16.jpg'>

- Recoil에서는 이 비동기 데이터를 핸들링을 할 수 있는 방법을 두 가지를 제안하고 있는데요

- RecoilState가 비동기 통신 중에 오류가 발생하면 `<RecoilRoot/>` 영역 전체가 렌더링되지 못하는 문제가 있습니다

- 이거는 하이브리드 앱을 구현 하시다보면 네이티브에서 특정 값을 내려받는 경우에 종종 경험할 수 있습니다

- 첫 번째 방법으로는 React에 에러 바운더리로 감싸 주는 거고 (왼쪽)

- 두 번째 방법은 아까 말씀드린 Loadable을 이용하는 방법입니다 (오른쪽)

- Loadable을 이용하면 값이 있을 때와 로딩 중일 때와 에러가 발생했을 때를 구분해서 처리해 줄 수 있습니다

- 여기까지도 큰 어려움 없이 구현을 했다고 생각을 했는데 실제 구현된 화면을 보면 한 가지 문제를 발견하실 수 있습니다

- Recoil에 비동기 state는 한 번 호출 되게 되면 무조건 캐싱을 하게 되는데

- 이것은 트래픽 비용을 절감할 수 있지만 데이터를 갱신 해 줘야 될 필요도 있습니다

<img src='./images/상태관리, 이제 Recoil로 하세요/17.jpg'>

- 또한 이런 문제들도 발생하게 되는데 Recoil 뿐만 아니라 비동기 데이터를 캐싱하는 다른 라이브러리들도 마찬가지로 발생할 수 있는 문제입니다

- 이는 서버 클라이언트 모델이 갖고 있는 근본적인 문제라고 볼 수 있는데요

- 데이터를 가져오는 시점과 실제 데이터를 사용하는 시점이 다른 경우에 발생합니다

- 특히 네이티브 앱 같은 경우에는 이런 단점을 보완하기 위해서 주기적으로 동기화하는 방식을 채택하기도 하는데요

- 이런 방식은 웹 환경에서 적용하기에는 생산성과 성능까지도 챙길 수 없는 방법이라고 볼 수 있습니다

<br/>

## 비동기 데이터를 갱신하는 방법들

- 그럼 이 비동기 데이터를 어떻게 갱신 해야 되냐 그 방법에 대해서 한번 알아보겠습니다

- 비동기 데이터 갱신에 영향을 주는 요소

  - 내부에서 구독중인 다른 Recoil state의 변경을 감지한 경우

  - 요청 파라미터가 완전 새로운 값으로 변경된 경우

- 공식 문서에서 비동기 데이터를 갱신할 수 있는 두 가지 방안을 제시하고 있습니다

- 설명하기에 앞서 아까 말씀드렸던 selector를 다시 한번 살펴보면 selector 내부에서 구독 중인 다른 state가 변경된 경우

- 그리고 family를 통해서 넘어온 요청 파라미터가 완전 새로운 값으로 변경 된 경우에 아까 selector가 재평가 되면서 리렌더링을 해 준다고 했습니다

<img src='./images/상태관리, 이제 Recoil로 하세요/18.jpg'>

- 이전 비동기 데이터를 가져오는 로직은 이렇습니다 여기서 갱신을 위한 값이 하나 더 필요해서 이 requestId 라는 atom을 추가해 주었는데요

- 쉽게 설명 드리면 api로 통신을 하는 횟수를 저장하는 atom이라고 생각하시면 됩니다

- 추가로 이 이렇게 requestId를 갱신 해줄 수 있는 함수를 하나 만들어 줬고요 결과적으로 이 refresh 함수가 실행되면 requestId는 갱신되면서 product selector가 재평가 되면서 새로운 데이터를 받아올 수 있게 되는 구조입니다

<img src='./images/상태관리, 이제 Recoil로 하세요/19.jpg'>

- selector 내에는 사용 되진 않지만 requestId를 구독하고 있는 걸 보실 수 있습니다

- 그리고 이 값을 변경해줄 refresh 함수를 하나 더 만들어줬고요

- 이 refresh 함수에서는 requestId를 순차적으로 증가시켜주는 로직이 포함되어 있습니다

- 따라서 이 refresh 함수를 실행 시켜 주면 requestId는 값이 올라가고 결국 이걸 참조하는 selector는 이 의존성으로 인해서 새로운 값을 불러올 수 있게 됩니다

<img src='./images/상태관리, 이제 Recoil로 하세요/20.jpg'>

- 저는 여기서 한 번 더 개선을 해 봤는데요

- 앞에 만들었던 refresh 함수를 만들지 않고 기존에 selector가 제공하는 setter 내에 이 requestId를 갱신 시켜 줄 수 있는 로직을 추가했습니다

- 함수를 호출 하던 대신에 selector의 setter를 실제 상태 변경이 없는 형태로 실행시켜 보면 조금 전과 동일한 효과를 받을 수 있는데요

- 그리고 여기에 사용된 request Id는 별도의 상태로 관리되기 때문에 다른 여러 selector에서도 구독 될 수 있고 이 구독되는 selector들을 동시에 갱신 시켜 줄 수 있는 장점이 있습니다

<img src='./images/상태관리, 이제 Recoil로 하세요/21.jpg'>

- 여기서 requestId와 같은 공유가 가능한 구독용 atom을 사용할 경우에 주의점이 있는데요

- atom은 별다른 제약이 없어서 어디서든 구독이 가능하기 때문에

- 원치 않는 상황에서 다른 selector에 의해서 영향을 받을 수도 있습니다

- 이런 종류의 atom은 가급적이면 private으로 정의 하는 게 좋습니다

- 만약 여러 영역에서 공유가 필요하다면 의존 관계를 갖는 상태끼리 파일로 관리하거나

- 또는 atomFamily를 이용해서 그룹화 할 수 있는 값을 매개변수로 받아서 그룹핑하는 방법도 생각해 볼 수 있을 것 같습니다

<img src='./images/상태관리, 이제 Recoil로 하세요/22.jpg'>

- 또 한 가지 방법으로는 공식 문서에서 조금 어려운 예시를 들고 있는데

- 이 비동기 데이터를 selector에 넣지 않고 atom으로 관리 하라는 건데

- 앞서 강조했던 구독으로 인한 의존성으로 인해서 데이터 자체는 주입하지 않고

- 별도의 selector를 이용 해서 재평가되는 시점에 이 값을 업데이트 해 주는 방식이라고 보시면 됩니다

<br/>

<img src='./images/상태관리, 이제 Recoil로 하세요/23.jpg'>

- 여기 프로필과 같은 데이터를 보면 사용자의 이벤트에 의해서만 이 값이 영향을 받는다고 보실 수 있습니다

- 따라서 이 값이 변경되는 시점이 예측이 가능하기 때문에 그 시점에 명시적인 업데이트를 해 줄 수 있는 겁니다

- 반면에 대부분의 데이터들이 언제 바뀔지 모르거나 매번 새로운 것을 요청해야 될 수도 있습니다

- 그런 경우에는 실시간이나 주기적으로 업데이트를 해줘야 되고 또는 아예 캐시 자체를 하면 안 될 수도 있습니다

<img src='./images/상태관리, 이제 Recoil로 하세요/24.jpg'>

- 좀 고전적이지만 확실하게 캐시를 컨트롤 할 수 있는 방식입니다

- 날짜와 family를 이용해서 서버로 요청할 때마다 매번 새로운 파라미터를 내려주면서 매번 새로운 값을 받아올 수 있기 때문에 캐시를 사용하지 않는 것과 동일한 효과를 줄 수 있고

- 시간을 1분이나 1시간 단위로 세부적으로 컨트롤이 가능해집니다

- 이렇게 구현된 화면을 보시면 api 요청 시마다 같은 행을 클릭했음에도 불구하고 새로운 값을 받아 보시는 걸 볼 수 있습니다

<img src='./images/상태관리, 이제 Recoil로 하세요/25.jpg'>

- 여기서 주의할 점은 버전 파라미터를 내부 state에 담아 가지고 useEffect를 통해 가지고 변경 하게 되면

- 실제 데이터를 받아 놓은 시점과 버전이 바뀌는 시점에 차이가 발생해서 중복적으로 데이터를 가져오는 그런 오류들이 발생하게 됩니다

- 그리고 이 버전 파라미터는 1초 미만으로 설정 할 경우에는 한 번 요청했을 때 상당히 많은 요청이 동시에 요청되는 걸 보실 수 있으니 주의하셔야 됩니다

- 실제 서비스를 구현하다 보면 수많은 상태와 데이터들이 복잡하게 얽혀 있는 것을 보실 수 있습니다

- 하나의 이벤트가 예기치 못하게 다른 데이터에 영향을 주는 경우도 있고 각각 다른 api를 통해서 내려왔지만

- 결국 실제 서버에서는 같은 곳을 바라보는 경우들이 있습니다

- 따라서 하나의 데이터가 변경되면 그 데이터를 사용하는 여러 곳에서 같은 상태를 보여 줘야 되는 그런 부분들이 있는데 결국 Recoil이 강조하는 핵심은 데이터 플로우 그래프를 잘 설계해서 의존성을 갖는 여러 상태들을 체계적으로 관리하라는 것 같습니다

<img src='./images/상태관리, 이제 Recoil로 하세요/26.jpg'>

- 잘 구현된 상태 관리라면 상태를 컴포넌트에서 최대한 가까이 두는 것이라고 합니다

- 전통적인 자바스크립트에서도 그랬듯이 전역 변수의 사용을 최소화하기를 권장하고 있구요

- 또한 여러 상태들을 각 용도에 맞게 잘 구분해서 설계하는 것도 중요할 것 같습니다

- 그리고 어떤 데이터가 언제 어떤 주기로 갱신이 필요한지도 예측하고 설계한다면 보다 사용성 높은 서비스를 만들 수 있을 것 같습니다

- 그 밖에도 Recoil에서는 저도 아직 접해보지 못한 다양한 기능들과 아직 실험적인 기능들이 많이 있습니다

  - constSelector: 상수 전용 셀렉터

  - errorSelector: 에러 전용 셀렉터

  - `Multiple<RecoilRoot>`` : 영역 분리와 중첩(상속 가능)

  - Concurrent Request - waitFor\*() : 비동기 데이터 동시 병렬 요청

  - Pre-Fetching - Snapshot: 렌더링 전 미리 데이터 조회

---

## Reference

- **[B1 상태관리, 이제 Recoil 하세요.](https://www.youtube.com/watch?v=0-UaleJZOw8&t=455s)**
