- 먼저 오늘의 발표 목차부터 설명해드릴게요

1. 컴포넌트란 ?

2. 프론트엔드에서 컴포넌트의 의미

3. 컴포넌트 잘 만들기 -> Headless 컴포넌트

---

## 1. 컴포넌트란 ?

- 먼저 컴포넌트란 뭘까요?

- 사전적 정의는 이와 같다고 해요

- 요소, 부품, 부분이라고 해요

- 근데 뭔가 부족하죠

- 그럼 엔지니어링 측면에서 컴포넌트는 뭘까요?

- 전체 시스템을 구성하는 하나의 부품 혹은 모듈이라고 해요

- 그럼 범위를 더 좁혀서 프론트엔드 엔지니어링 측면에서 컴포넌트는 뭘까요?

- 바로 UI를 구성하는 UI 요소라고 해요

- 그러니까 프론트엔드에서 전체 시스템은 UI가 되고 전체 시스템을 구성하는 모듈 혹은 부품은 UI 요소가 될 거예요

---

## 2. 프론트엔드에서 컴포넌트의 의미

- 그러면 이제 프론트엔드에서 컴포넌트의 의미를 알아볼게요

- 프론트엔드에서 어쩌다 컴포넌트라는게 중요해졌는지 과거의 웹 구조를 통해서 알아보도록 하겠습니다

- 먼저 과거의 웹 페이지는 사용자가 어떤 인터렉션 요청을 보내면 그러니까 데이터 수정 요청을 보내면 그 때마다 매 번 서버에서 HTML 페이지를 새로 생성 해서 받아왔어야 해요

- 그래서 마치 웹 하나가 전체의 덩어리처럼 움직이게 돼요

- 그래서 부분만 사실 수정하면 될텐데 그때마다 계속해서 서버에서 HTML 전체를 받아와서 클라이언트에서 보여줘야했기 때문에 매우 불편했어요

- 그래서 이러한 문제점들이 발생하게 되는데요

- **첫 번째로 사용자 측면에서 웹 복잡도가 높아지고 사용자 인터랙션이 점점 증가함에 따라서 사용자 경험이 떨어질 수밖에 없었어요**

- 왜냐하면 HTML을 계속해서 새로 받아옴으로써 계속 깜빡이게 되고 화면 깜빡임이 생기고 속도도 느릴 수 밖에 없거든요

- **두번째로 개발자 측면에서 재사용의 어려움이란 문제가 있었어요**

- HTML 페이지마다 중복되는 코드들이 계속 분산이 되어 있어서 유지 보수에 매우 취약했죠

- 그래서 이런 방식을 AJAX 방식으로 해결할 수 있었어요

- 이제 AJAX 방식을 통해서 데이터 수정 요청이 들어오면 서버에서 JSON 데이터를 보내고 클라이언트에서는 이제 HTML의 자바스크립트를 통해서 일부분만 수정할 수 있게 되었거든요

- 그래서 이제 하나의 웹은 덩어리처럼 존재하지 않고 마치 부분 부분 컴포넌트 부분 조각처럼 존재할 수 있게 되었어요

- 그러니까 어떤 부분 데이터 수정 요청이 들어왔을 때 전체가 리로드 되는게 아니라 부분만 리로드되면 됐어요

- 그래서 저희는 이제 웹을 하나의 컴포넌트 단위로 구분할 수 있게 되었습니다

- 이렇게 컴포넌트는 결국 UI, 전체 시스템 UI라는 곳에서 UI 요소 부품이 되는 거예요

- 그래서 저희는 이제 **컴포넌트를 잘 만든다는 결국 유지보수를 용이하게 한다는 뜻**과 같지 않을까요?

- 그래서 프론트엔드 개발자에게 컴포넌트는 굉장히 중요한 개념이 되었어요

---

## 3. 컴포넌트 잘 만들기 - Headless 컴포넌트

- 이제 컴포넌트가 왜 중요한지 알아봤으니까 컴포넌트 잘 만들어봅시다!

- 부제는 Headless 컴포넌트예요

- 근데 대부분 컴포넌트 잘 만든다 하면 컴포넌트 분리법 이렇게 생각하실 수 있어요

- 근데 저는 오늘은 컴포넌트 분리보다 컴포넌트를 어떻게 하면 잘 설계할지에 더 초점을 두고 싶었어요

- 왜냐하면 일단 컴포넌트를 잘 만들면 분리도 쉬워질 거라고 생각했거든요

- 그래서 저는 이번 장을 통해서 해결하고자 하는 문제는

- 첫번째, **재사용 가능한 컴포넌트를 만들고**

- 두번째, **변경에 따른 부수효과를 최소화**하는 거예요

- 왜냐하면 저희의 요구사항은 계속 변하잖아요?

- 소프트웨어의 요구사항은 계속 변하는데 그 때마다 재사용 가능하지 않은 컴포넌트거나 변경에 따른 부수효과가 많으면 리소스가 많이 들어가기 때문이죠

- 컴포넌트 하나를 요구사항 변경에 따라서 계속해서 대대적으로 수정을 하면은 그 때마다 개발자가 계속해서 일을 해야겠죠

- 그래서 저는 이번 장의 목표를

- **관심사가 분리된**

- **재사용성이 높고 유지보수하기 용이한 컴포넌트**를 만드는 걸로 했습니다

- 관심사가 분리된게 왜 재사용성이 높고 유지보수 하기가 용이할까요?

- 이거는 제가 Headless 컴포넌트를 통해서 이제 뒤에서 더 설명해드리도록 하겠습니다

- Headless가 무엇인지는 뒤에서 더 자세하게 설명해드릴거예요

- 대신 저희가 일반적으로 컴포넌트를 어떻게 만드는지 컴포넌트를 직접 만들어 보면서 이 문제점을 함께 파악해 봅시다

- 이런 input 컴포넌트가 요구사항에 왔다고 생각을 해보세요

- 그러면 저는 React 코드로 한 번 코드를 짜 볼게요

<img src='./images/호프의 프론트엔드에서 컴포넌트/01.png'>

- SomeInput이라는 컴포넌트를 만들 것 같아요

- 일단 안에 input이니까 value가 필요할 것 같아요

- 그래서 useState를 통해서 value를 정의해줬어요

- 그리고 이 input이 사용자에게 어떻게 보여질지 UI를 정의해줘야겠죠

- 그래서 요렇게 JSX를 정의해줬어요

- 그리고 이 마크업과 이 value, 데이터를 연결하기 위해서 이벤트 핸들러도 정의해줬어요

- 잘 만든 것 같아요

- 이 input이 아마 잘 렌더링되고 잘 실행이 될 거예요

- 다음 날 기획자가 이런 input을 만들어 달라고 했어요 어떻게 할까요?

<img src='./images/호프의 프론트엔드에서 컴포넌트/02.png'>

- 아까 그 someInput 컴포넌트를 재사용하기는 어려울 것 같아요

- 왜냐하면 UI가 달라졌거든요

- 그런데 잘 보면 input 자체의 데이터 로직은 똑같아요

- 그럼 저희가 어떻게 이걸 해결할 수 있을까요?

- 바로 생각나는 방법은 아마 다른 컴포넌트를 만들거나

- 혹은 props로 스타일링 옵션을 줘서 분기 처리를 하는 것 뿐이에요

- 근데 다른 컴포넌트를 만드는 것은 결국 우리 아까 만들었던 someInput 컴포넌트가

- 재사용이 불가능하다는 것을 입증한 거고 props로 스타일링 옵션을 내려주는 것은

- 사이드 이펙트를 초래하게 됩니다

- 왜 이런 문제가 발생했을까요?

- 제 생각에는 데이터를 다루는 로직과 UI 로직이 하나의 컴포넌트에 뭉쳐있기 때문이라고 생각을 했습니다

<img src='./images/호프의 프론트엔드에서 컴포넌트/03.png'>

- 결국 이 데이터를 다루는 로직 input의 데이터로직은 계속해서 반복이 되는데 이 UI 만 바뀌게 되잖아요?

- 근데 이게 하나의 컴포넌트에 뭉쳐있다?

- 즉, 하나의 컴포넌트에 두 개의 관심사가 뭉쳐있어서 발생된 문제라고 생각을 했습니다

- 그래서 이렇게 계속해서 다른 UI를 요구를 할텐데 요구 상황에서 다른 UI 지만 같은 데이터 로직을 가진 요구사항이 나올텐데 이 때마다 계속해서 다른 새로운 컴포넌트를 만들어야 할까요?

<img src='./images/호프의 프론트엔드에서 컴포넌트/04.png'>

- 혹은 이 때마다 props에 스타일링 옵션을 줘서 계속 분기 처리를 해야 할까요?

- 정말 너무 비효율적이죠

- 그래서 저는 이 문제를 Headless라는 개념으로 한 번 해결해보고 싶었어요

- 즉, **하나의 컴포넌트에 두 가지 관심사가 존재하는 문제를 Headless하게 만들어 보는 거예요**

- 그럼 Headless가 대체 뭘까요?

<img src='./images/호프의 프론트엔드에서 컴포넌트/05.png'>

- 말 그대로 Headless, 머리가 없다는 뜻이거든요

- 그럼 머리가 뭐고 몸통이 뭔지부터 알아야겠죠?

- 왜 머리가 없는건가?

- 몸통은 일단 컨텐츠 자체를 의미한다고 합니다

- 그럼 머리는 컨텐츠를 보여주는 방법이라고 해요

- 근데 이렇게까지 얘기하면 약간 이해가 안 될 수 있어요

- 근데 이 Headless라는 개념이 엔지니어링에서만 사용되는 건 아니라고 합니다

- 제가 찾아보니 굉장히 여러 가지가 있더라고요

<img src='./images/호프의 프론트엔드에서 컴포넌트/06.png'>

- 근데 대표적으로 두 가지 Headless 브라우저와 Headless 커머스가 있어요

- Headless 브라우저는 GUI 환경이 아니라 CLI, 커맨드라인으로 실행되는 브라우저를 의미한다고 해요

- 이런 브라우저가 있더라고요 사용자 인터페이스 없이 CLI만 있는 거예요

- 즉 이거 역시 GUI는 Head에 해당하겠죠?

- 그리고 CLI에 구현될 뭔가 브라우저 자체의 데이터 로직은 Body에 해당할 거예요

- 그래서 GUI 환경을 날려버린 브라우저가 바로 Headless 브라우저가 되고 Headless 커머스는 프론트엔드와 백엔드를 나눠서 제공하는 시스템 기술이라고 해요

- 그래서 프론트엔드는 결국 고객이 대면하는 UI 백엔드는 결제 시스템, 재고관리 기능 등을 의미하는데

- 이 두 가지를 나눠서 제공하는게 Headless 커머스라고 합니다

- 그러면 프론트엔드에서 Headless는 무엇을 의미할까요?

<img src='./images/호프의 프론트엔드에서 컴포넌트/07.png'>

- 저희가 아까 만들었던 컴포넌트에 Headless를 적용하면 어떻게 될까요?

- Head는 뭐고 Body는 뭐가 될까요?

- Head는 결국 UI, 콘텐츠를 보여주는 방법이니까 아마 UI가 되겠죠?

- 그리고 Body는 컨텐츠 자체 그러니까 데이터가 될 것 같아요

- 그러면 Headless, 머리를 없애야 하니까

- 저희는 UI를 없애야 합니다

- Body만 남겨야 해요

<img src='./images/호프의 프론트엔드에서 컴포넌트/08.png'>

- 데이터만 남긴 컴포넌트가 바로 Headless 컴포넌트예요

- 그러면 저희가 아까 만들었던 input 컴포넌트를 어떻게 Headless하게 만들지 고민을 해볼게요

<img src='./images/호프의 프론트엔드에서 컴포넌트/09.png'>

- 남길 부분과 남기지 않은 부분을 나눠놨어요

- 남길 부분, 즉 Body에 해당하는 부분은

- 아마 input의 value값, onChange handler 그 외에 만약에 필요한 Input Attribute들이 있을 것 같아요

- 그리고 날려야 하는 부분

- 즉, Head에 해당하는 부분은

- input이 어떻게 보여질건지 사용자에게 UI에 해당하겠죠

- 그러면 우리 Headless 컴포넌트를 만들어 봅시다

- 제가 패턴, 대표적으로 사용되는 세 가지 패턴을 가져왔는데 저는 아주 간단하게만 설명할 거라서 혹시 이 패턴에 대해서 더 궁금하시면

- 더 깊게 찾아보시는 걸 추천드립니다

- 그리고 이 패턴들이 무조건적인 정답은 아니에요 다만

- Headless라는 개념을 굉장히 잘 녹여낼 수 있는 패턴이라는 것을 인지해주시길 바랍니다

---

### 1. Compound Component 패턴

- 첫 번째로 Compound Component 패턴이에요

- Compound는 화합물이라는 뜻이거든요

- 무엇의 화합물일까요?

- 바로 컴포넌트의 화합물입니다

- 그래서 제가 Compound Component 패턴을 어떻게 구현하는지

- 간략하게 설명을 드릴게요

<img src='./images/호프의 프론트엔드에서 컴포넌트/10.png'>

- 일단 아까 Body에 해당하는 데이터 로직을 컨텍스트 API에 정의를 해줍니다

- 이렇게 해서 컴포넌트 내부에서 공유될 상태를 미리 정의를 해놔요

- 그리고 InputWrapper, 즉 부모 컴포넌트를 정의해줘서 InputWrapper 부모 컴포넌트에서 컨텍스트 API를 공유하게 돼요

- 그리고 자식 컴포넌트, 이 안에 들어간 input과 label 컴포넌트를 선언을 해서

- 이렇게 이 안에서는 useContext를 통해서 부모의 데이터를 공유받습니다

- 공유받고 접근할 수 있어요

- 그리고 이건 선택사항인데 InputWrapper, 즉 부모 컴포넌트의 프로퍼티로 자식 컴포넌트를 등록을 해서

- 명시적으로 InputWrapper와 input 그리고 InputWrapper와 label이 부모 자식 관계에 있구나를 명시적으로 나타낼 수가 있어요

- 자식 컴포넌트들이 이렇게 컨텍스트를 통해서 부모 컴포넌트에서 공유하고 있는 데이터에 접근을 함으로써 외부에서 봤을 때는 이 자식 컴포넌트와 부모 컴포넌트들이 데이터를 공유하고 있는지 몰라요

- 암묵적으로 자식 컴포넌트에서 부모 컴포넌트의 데이터를 접근하게 되는 거예요

- 왜냐하면 저희는 일반적으로 부모와 자식 간의 데이터를 공유한다고 했을 때 props로 내려주는 방법을 떠올릴 수밖에 없거든요

- 그럼 왜 이런 방법이 유리하게 될까요?

- 바로 사용처를 보면 알 수 있는데요

<img src='./images/호프의 프론트엔드에서 컴포넌트/11.png'>

- 이렇게 InputWrapper, 부모 컴포넌트 아래 자식 컴포넌트를 정의해줍니다

- 그런데 이게 사용하는데서는

- InputWrapper의 하위 컴포넌트를 자유롭게 볼 수 있고 위치를 수정해서 마크업을 수정할 수 있습니다

- 그리고 여기서 데이터, 그러니까 부모 컴포넌트의 데이터에 의존하고 있다는 것을 모르기 때문에 자유롭게 이 사용처에서 쓸 수 있어요

- Headless하지 않은 컴포넌트, 우리가 아까 만들었던 컴포넌트 사용처와 비교해 보면 많이 차이가 나죠

- 이전에는 그냥 덩어리로 Input 컴포넌트를 썼어야 했다면 여기서 부모와 자식을 나눠서 자식 부분을 저희가 알아서 커스터마이징 할 수 있어요

- 그러면 다음 패턴을 알아보죠

---

### 2. Function as Children Component 패턴

- 다음은 Function as Children Component 패턴이에요

- Children Component로서의 함수

- 즉, Children Component로 함수가 들어온다는건데요

- 이렇게 보면 사실 아까거와 별로 다르지 않아보여요

<img src='./images/호프의 프론트엔드에서 컴포넌트/12.png'>

- 데이터 로직이 있고 뭔가를 리턴해주는데

- 잘 보면 children을 실행한 결과를 리턴을 해줘요

- 그러니까 children의 타입이 function이라는 거예요

- 왜일까요?

- 자식에 어떤 것이 들어올지 모른다고 가정을 하기 때문이에요

- 여기서 InputHeadless 컴포넌트에서는

- 데이터 로직만 선언을 해주고 여기서 필요한 데이터 로직

- 그러니까 children에서 필요한 데이터 로직을 children의 매개변수로 주입을 해줍니다

- 그러면 children에서는 이렇게 마음대로 사용할 수 있어요

<img src='./images/호프의 프론트엔드에서 컴포넌트/13.png'>

- 매개변수로 받은 데이터로직을 마크업에 따라서 마음대로 사용할 수 있어요

- 매우 Headless하죠

- 즉 데이터 로직은 분리되어 있고 마크업을 저희가 마음대로 바꿀 수 있어요

---

### 3. Custom Hook 패턴

- Headless 컴포넌트 만들기 마지막 패턴을 설명해드릴게요

- Custom Hook 패턴인데요

- 제 생각에 React 코드를 작성하시면서 이 패턴은 본인이 이게 Headless인지도 모르고 사용하셨을 경우가 많을 것 같아요

- 왜냐하면 여기서는 아까 봤던 Body에 들어갈, 그러니까 데이터 로직들을 use~ 여기서는 useInput이 되겠죠?

<img src='./images/호프의 프론트엔드에서 컴포넌트/14.png'>

- Custom Hook에 정의를 해놓고 사용처에서 이렇게 실행을 해서 사용을 하게 됩니다

- 그래서 어느 곳에서나 사용할 수 있어요

- 여기서 이제 마크업, 해당 마크업에 해당 데이터로직을 붙여주게 되는 거죠

- 그래서 이 부분만 변경이 되면 계속해서 다른 UI가 요구사항으로 와도 저희는 대응을 할 수 있습니다

- 이 데이터 로직은 계속 똑같거든요

- 이 데이터 로직 을 계속 재사용할 수 있겠어요

- 자 그러면 이렇게 여기까지 Headless 컴포넌트를 만드는 세 가지 패턴을 알아보았고 Headless 컴포넌트가 무엇인지 왜 필요한지까지 살펴보았어요

- 간략하게 말씀을 드리자면 Headless 컴포넌트, Headless 패턴의 주요 핵심 가치는 관심사의 분리예요

- 데이터 로직과 UI 로직을 분리하는 거예요

- 근데 개발을 하면서 이게 필요할 때도 있고 안 필요할 때도 있을 것 같아요

- 이 Headless 컴포넌트를 만드는게 무조건적인 해답은 아니라는 거 숙지해주시고

- 가끔 관심사의 분리가 필요하다 싶은 컴포넌트에 적용을 해주시면 좋을 것 같습니다

---

## Reference

- [호프의 프론트엔드에서 컴포넌트](https://www.youtube.com/watch?v=aAs36UeLnTg&t=614s)

- 참고자료

  - [Headless 컴포넌트](https://www.howdy-mj.me/design/headless-components)

  - [The Sexiness of Headless UI Components](https://www.joshbritz.co/posts/the-sexiness-of-headless-ui/)

  - [Select 컴포넌트](https://so-so.dev/react/make-select/)

  - [The complete guide to building headless interface components in React](https://blog.logrocket.com/the-complete-guide-to-building-headless-interface-components-in-react/)

  - [React Hooks: Compound Components](https://kentcdodds.com/blog/compound-components-with-react-hooks)

  - [Inversion of Control](https://kentcdodds.com/blog/inversion-of-control)

  - [이커머스 시장의 뉴노멀, 헤드리스 커머스](https://brunch.co.kr/@groobee/268)
