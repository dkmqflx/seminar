<img src='./images/Sentry를 이용한 에러 추적기, React의 선언적 에러 처리/01.png'>

- 에러 발생시 각 케이스 별로 보여줘야 하는 화면이 다르다

- 여기서 일반적인 에러 화면은 API 에러 또는 화면에서 런타임 에러가 발생한 경우 보여주는 화면이다

<br/>

<img src='./images/Sentry를 이용한 에러 추적기, React의 선언적 에러 처리/02.png'>

- 앞의 화면에 대한 에러처리를 해주고 있는 코드.

- 대부분 프론트엔드의 에러는 API 호출시 발생하기 때문에 axios의 인터셉터를 활용했다.

- API 응답시 에러가 발생하면 인터셉터의 reject 콜백을 호출하게 되며

- 공통 에러 코드 및 각 서비스의 백엔드에서 정의한 에러 코드와 HTTPS의 Status 코드를 확인하고 우선순위가 높은 에러 처리 방식을 적용한다

- 네트워크 에러의 경우, 네트워크 에러 핸들러 함수를 실행하고

- 타임아웃 에러인 경우에는 타임아웃 에러 핸들러 함수를 실행한다

- 백엔드와 정의한 에러 코드를 확인하고 해당 하는 에러 핸들로 함수로 보내는 과정을 확인할 수 있다.

- reject 콜백을 이용한 공통처리는 편한 부분도 있었지만 예외 케이스가 있을 경우 추가되는 코드가 늘어났고 전역에서 처리하는 흐름이 맞을지에 대한 의문이 생기기도 했다.

<br/>

<img src='./images/Sentry를 이용한 에러 추적기, React의 선언적 에러 처리/03.png'>

- axios 인터셉트를 이용하면 명령형으로 에러 처리를 하게 되고

- 에러 화면을 보여주려면 reject 콜백에서 history.push를 통해 라우트 이동으로 에러 페이지로 보내거나

- 해당 api를 호출하는 코드에서 일일이 에러의 발생 여부를 판단하고 에러를 표시해야 했다

<img src='./images/Sentry를 이용한 에러 추적기, React의 선언적 에러 처리/04.png'>

- axios의 인터셉터에서 처리하게 되면 에러 페이지 화면을 보여주는 것은 어렵지 않지만

- 화면 일부만 에러 fallback으로 처리하고 싶다면 인터셉터에서는 예외로 처리하고 호출부에서 대응해야 한다

- 이러한 에러 처리에 어려움을 개선해 보고자 리액트에서 제공하는 에러 바운더리에 대해서 살펴보기 시작했다.

<br/>

<img src='./images/Sentry를 이용한 에러 추적기, React의 선언적 에러 처리/05.png'>

- 에러 바운더리는 리액트 16에서 도입된 기능으로 이를 활용하면 하위 컴포넌트 트리의 자바스크립트 에러를 포착하고 fallback ui를 보여줄 수 있다

- 에러바운더리에 대해 알아보기 전에 명령형 프로그래밍과 선언용 프로그래밍에 대한 패러다임을 먼저 살펴볼 필요가 있다

- 명령형 프로그래밍은 어떻게에 대한 것으로, 즉, 원하는 결과를 달성해 나가는 과정에 관심을 두는 프로그래밍 스타일

- 선언형 프로그래밍은 무엇을 기술하는데 방점을 두고 구조를 세워 나가는 프로그래밍 스타일

<img src='./images/Sentry를 이용한 에러 추적기, React의 선언적 에러 처리/06.png'>

- 명령형 에러 처리는 어떻게 화면에 에러를 보여줄지에 집중하여 코드를 작성할 수 있다.

- try-catch에서 에러를 포착하면 에러 상태값을 변경하여 해당하는 화면을 보여줌으로써 에러를 처리한다

- 선언형 에러 처리는 무엇을 보여줄지를 코드를 통해 결정할 수 있는데 리액트는 기본적으로 선언형으로 무엇을 렌더링 할지를 나타내고 있다

- 에러 바운더리는 이러한 리액트의 선언적 특성을 따르고 가장 가까운 에러 바운더리로 에러를 전달한다

<img src='./images/Sentry를 이용한 에러 추적기, React의 선언적 에러 처리/07.png'>

- 위 코드의 형태가 리액트 공식 문서에서 설명하는 에러 바운더리의 기본 구조이며 리액트 컴포넌트를 상속하면 제공하는 getDrivedStateFromError 메서드와

- compnentDidCatch 메서드를 통해서 에러를 감지하고 상태값의 변화를 통해 fallback ui를 보여줄 수 있도록 구현할 수 있다

<br/>

<img src='./images/Sentry를 이용한 에러 추적기, React의 선언적 에러 처리/08.png'>

- 에러 바운더리를 리액트 컴포넌트를 상속하여 직접 구현할 수도 있지만 라이브러리를 사용하면 좀 더 편리하게 사용이 가능하다.

- react-error-boundary 라이브러리는 에러바운더리를 편리하게 다룰 수 있도록 도와주는 라이브러리

- fallback 컴포넌트를 다양한 방식으로 작성할 수 있고 reset 함수와 reset을 트리거하는 키 설정도 제공한다.

<img src='./images/Sentry를 이용한 에러 추적기, React의 선언적 에러 처리/09.png'>

- 리액트의 에러 바운더리는 이벤트 핸들러 내부에서는 에러를 포착하지 않는다.

- 때문에 함수에서 api를 호출했을 때는 오류가 발생하더라도 이를 에러 바운더리로 전송하지 않는다.

- 카카오페이의 대부분의 서비스들이 리액트 쿼리를 활용하여 비동기 데이터 통신을 하고 있는데

- 리액트 쿼리에서는 useErrorBoundary 옵션을 제공하여 API 호출시 에러가 발생하면 근접한 에러 바운더리로 전달한다.

- 다음은 에러 바운드리를 통해 선언적 에러 처리로 어떻게 개선해 나갔는지에 대한 예재 코드와 그 과정에 대한 설명이다

<br/>

<img src='./images/Sentry를 이용한 에러 추적기, React의 선언적 에러 처리/17.png'>

- 먼저 axios 인터셉터의 로직을 줄여보기로 했다.

- axios 인터셉터에서 글로벌하게 처리하고 있었던 에러 처리를

<img src='./images/Sentry를 이용한 에러 추적기, React의 선언적 에러 처리/10.png'>

- 아래처럼 네트워크 에러에 대한 지연 처리 외에는 어떠한 에러도 핸들링을 하지 않도록 하고 에러 바운더리로 위임하도록 변경했다

<img src='./images/Sentry를 이용한 에러 추적기, React의 선언적 에러 처리/11.png'>

<br/>

- 두 번째로는 에러바운더리에 관심사를 분리해 보았다

<img src='./images/Sentry를 이용한 에러 추적기, React의 선언적 에러 처리/12.png'>

- 앞서 인터셉터에서 불리한 API 에러를 처리하는 코드는 API 에러 바운더리에서 처리하도록 하고

- 프론트엔드에서 발생할 수 있는 그 외에는 루트 에러 바운더리에서 처리하도록 하였다

<img src='./images/Sentry를 이용한 에러 추적기, React의 선언적 에러 처리/13.png'>

- 이렇게 중첩적으로 구성하면 하위 에러 바운더리 컴포넌트부터 우선적으로 적용이 되고 관심사의 분리가 가능하다.

<br/>

- 마지막으로는 fallback 컴포넌트에서 세부적인 에러 처리를 하도록 로직을 작성하였다

<img src='./images/Sentry를 이용한 에러 추적기, React의 선언적 에러 처리/14.png'>

- 이렇게 관심사가 분리된 각각의 에러 바운더리가 다양한 에러코드 또는 상황에 따라 정의한 화면을 노출하도록 fallback 컴포넌트를 작성하였다

<img src='./images/Sentry를 이용한 에러 추적기, React의 선언적 에러 처리/15.png'>

- 이때 리액트 쿼리의 useQueryErrorResetBoundary 훅을 사용하여 reset 함수를 onReset의 props로 넘겨주면

- fallback 컴포넌트에서 resetErrorBoundary 라는 메서드로 활용할 수 있으며 이를 화면과 연결하여 쿼리를 리셋할 수 있다

- 이를 통해 필요에 따라 api를 재호출할 수 있다

- 필요한 경우 location 객체의 키를 기반으로 에러 상태를 리셋하여 라우트 이동이 일어났을 때 오류 화면이 남아 있는 것을 방지할 수 있다

<br/>

- fallback 컴포넌트 내에서 처리할 에러가 아니라면 다시 throw를 해서 상위 에러 바운더리로 위임하는 것도 가능하다

<img src='./images/Sentry를 이용한 에러 추적기, React의 선언적 에러 처리/16.png'>

- fallback 컴포넌트에서는 앞서 part1에서 살펴보았던 sentry와 같은 에러 모니터링 서비스에 에러 데이터를 전송할 수도 있다

<br/>

- 에러를 상위로 전파시키지 않고 부분적으로만 처리할 수 있는 점이 에러 바운더리에 장점이다

<img src='./images/Sentry를 이용한 에러 추적기, React의 선언적 에러 처리/18.png'>

- 이를 핸들링 하기 위해서 루트 레벨의 에러바운더리 뿐만이 아니라 로컬 레벨의 에러바운더리 컴포넌트를 구현하여 사용하고 있다

- 다만 force 업데이트와 같은 루트 레벨에서 처리하여야 하는 에러는 상위 에러 바운더리로 전파하도록 예외 처리가 필요하다.

<img src='./images/Sentry를 이용한 에러 추적기, React의 선언적 에러 처리/19.png'>

- 앞서 센트리 분석을 통해 발견했던 오류 케이스 중 ios에서 unload 이벤트가 발생하면 axios 에서 호출 중이던 api에서 네트워크 에러가 발생하는 사례가 있었다

<img src='./images/Sentry를 이용한 에러 추적기, React의 선언적 에러 처리/20.png'>

- 이러한 애러는 에러바운더리가 포착해서 오류 화면을 보여주면 안 된다.

- 따라서 인터셉터에서 네트워크 에러로 인식되는 에러가 발생한 경우 에러 처리를 200mm 정도 지연시키면 오류 화면이 보여지기 전에 앱이 unload 된다.

<br/>

- 지금까지 선언적 에러 처리를 이용해 에러 처리를 개선해 나갔던 과정들을 살펴보았는데 개선 후 이런 점들이 좋아졌다.

- 가장 큰 장점은 비즈니스 로직에 집중한 에러 처리가 가능하다는 점이다

<img src='./images/Sentry를 이용한 에러 추적기, React의 선언적 에러 처리/21.png'>

- 명령형 에러처리 방식으로 구현하는 경우 에러가 발생할 수 있는 모든 로직을 고려하여 fallback ui를 대응해야 하고 데이터와 상태 자체에만 집중할 수 없다

<img src='./images/Sentry를 이용한 에러 추적기, React의 선언적 에러 처리/22.png'>

- 선언적 에러 처리를 하는 경우 모든 에러에 대한 처리는 에러 바운더리로 위임하고 로직에서는 에러 발생에 대해 신경 쓰지 않아도 된다.

<img src='./images/Sentry를 이용한 에러 추적기, React의 선언적 에러 처리/23.png'>

- 또한 UI 일부에서 발생하는 에러를 전역으로 전파시키지 않고 처리할 수 있다

- useSomeQuery에서 에러가 발생하더라도 Parent 컴포넌트의 에러 바운더리에서 이를 캐치하기 때문에 에러는 전역으로 퍼지지 않는다

<img src='./images/Sentry를 이용한 에러 추적기, React의 선언적 에러 처리/24.png'>

- 다만 강제 업데이트, 계정 이상, 점검 등이 발생한 경우 전역 레벨의 에러 바운더리가이를 처리하도록 해야 한다.

- 따라서 fallback에서 이를 구분하고 다시 throw 에러를 위임해야 한다.

- 그러므로 개발자는 애플리케이션에서 발생할 수 있는 에러에 대해 충분히 인지하고 있어야 한다

<br/>

- 프론트엔드에서 발생할 수 있는 오류는 데이터 영역에서의 오류, 화면 영역에서의 오류, 런타임 오류 및 예측할 수 없는 오류들이 존재한다

- sentry의 다양한 기능을 이용하여 에러 데이터 뿐만이 아니라 디버깅에 필요한 유의미한 데이터를 수집할 수 있으며 수집 데이터를 기반으로 분석하여 사용자 경험을 개선시킬 수 있다

<img src='./images/Sentry를 이용한 에러 추적기, React의 선언적 에러 처리/25.png'>

- 선언적 에러 처리를 통해 비즈니스 로직 작성에 더욱 집중할 수 있으며 각 케이스별 에러 처리에 관심사를 분리할 수 있다

- sentry의 사용과 선언적 에러 처리는 사용자 경험과 개발자 경험을 향상시킬 수 있으며 견고한 서비스를 만드는데 많은 도움을 줄 수 있다.

---

## Refernece

- [Sentry를 이용한 에러 추적기, React의 선언적 에러 처리 / if(kakao)2022](https://www.youtube.com/watch?v=012IPbMX_y4)
