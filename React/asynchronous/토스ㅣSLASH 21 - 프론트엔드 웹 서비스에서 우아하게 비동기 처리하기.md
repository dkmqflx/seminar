- 토스에서는 60개 이상의 크고 작은 활성 서비스가 웹 기술을 이용해서 개발되고 있다

- 그 외에 홈페이지나 토스 증권, 토스 페이먼트, 토스 인슈어런스 등의 서비스는 100% 웹 기술을 이용해서 개발되고 있다

- 토스의 앱 안에서는 주식 탭, 혜택 탭 등이 대표적으로 웹 서비스를 이용해서 개발된 서비스이다.

- 이렇게 많은 서비스 들은 마이크로 프론트엔드 아키텍처를 이용해서 같은 레포지토리 안에서 독립적으로 개발 배포되고 있다

<img src="./images/토스ㅣSLASH 21 - 프론트엔드 웹 서비스에서 우아하게 비동기 처리하기/00.png">

- 모든 서비스들은 리액트, 타입스크립트, Next.js 라고 하는 기술 스택을 공유하고 있고 구체적인 로직만 다르게 가져가고 있다

<br/>

- 웹에서는 10여년전 제이쿼리와 같은 라이브러리 를 쓰면서 명령어로 프로그래밍을 하다가

- 래액트, 뷰와 같이 선언적인 프로그래밍을 지원하는 프레임워크들이 나오면서 각각의 개발자가 신경써야 하는 부분들이 많이 줄어 들었는데

- 그럼에도 아직까지 다루기 어려운 영역을 하나 꼽아 보자면 비동기 프로그래밍이라고 할 수 있다.

- 비동기 프로그래밍은 순서가 보장되지 않는 상황 이라고 요약할 수 있다

<img src="./images/토스ㅣSLASH 21 - 프론트엔드 웹 서비스에서 우아하게 비동기 처리하기/01.png">

- 예를 들어 웹브라우저가 서버에 요청을 보냈는데 서버에 응답 만을 기다리고 다른 유저 인터랙션에 반응하지 않는다면 그냥 멈춰 있게 된다.

- 이렇게 하는 대신 서버에 요청을 보내고 기다리는 게 아니라 다른 작업을 하면서 사용자에게 좋은 경험을 보여주다가

- 서버 응답이 돌아오면 다시 이어서 할 일을 하는 이런 모습이 비동기 프로그래밍을 대표적으로 나타내는 모습 중 하나이다.

- 이렇게 비동기 프로그래밍은 끊기지 않는 60 프레임의 좋은 사용자 경험을 위해서는 필수이고

- 자바스크립트에서는 Callback, Promise, Observable과 같이 다양한 도구를 이용해서 비동기 적인 상황을 다루고 있다

- 그렇지만 비동기 프로그래밍이 아직까지 ui 프로그래밍에서 어려운 부분이라고 생각한다.

<br/>

- 잠시 좋은 코드에 대한 생각으로 한번 돌아가 보자

- 좋은 코드 라고 하는 말에 대해 여러 가지 생각을 가지고 있을 것이다.

- 자신의 분명한 책임을 드러내는 함수와 변수, 응집도, 느슨한 결합, 의존성의 역전 등 많은 부분에 대한 이야기가 있는데

- 이번 발표에서 다양한 코드들을 살펴보면서 이 코드가 어떤 문제점을 가지고 있고

- 이 코드는 어떤 좋은 점을 가지고 있는지에 대해서 한번 살펴 보면서 좋은 코드에 대한 원칙들을 세워보자 한다.

<br/>

- 아래 코드가 하는 역할을 살펴보자

<img src="./images/토스ㅣSLASH 21 - 프론트엔드 웹 서비스에서 우아하게 비동기 처리하기/02.png">

- `x` 가 없으면 없는 걸 반환하고

- `x.foo` 가 없으면 없는걸 반환한다

- `x.foo.bar.baz` 라고 하는 프로퍼티에 안전하게 접근하려고 하는 코드이다

- 이 코드의 문제점은 다음과 같다

<img src="./images/토스ㅣSLASH 21 - 프론트엔드 웹 서비스에서 우아하게 비동기 처리하기/08.png">

- 이 코드에는 어떤 문제점이 있을지 보면 함수가 하는 일은 굉장히 단순한데 비해서 코드가 복잡하다

- 이 함수가 하는 일을 요약한다면 `x.foo.bar.baz`라고 하는 프로퍼티에 안전하게 접근하는 일인데

- 함수가 하는 일이 명확하게 드러나기 보다

- "`x` 가 없는지 검사한다. `x.foo`가 없는지 검사합니다" 와 같이 명령어의 노이즈가 많아서 함수가 어떤 역할을 하는지 며 하게 드러나지 않는다고 생각한다.

- 반면 최근의 ECMA Script에 추가된 옵셔널 체이닝 문법을 활용한 동일한 함수를 살펴보자

<img src="./images/토스ㅣSLASH 21 - 프론트엔드 웹 서비스에서 우아하게 비동기 처리하기/03.png">

- 이 함수가 읽기가 좋은 이유는 이전에 이유들을 해결하고 있기 때문이다.

- 이 코드가 좋은 이유는 다음과 같다

<img src="./images/토스ㅣSLASH 21 - 프론트엔드 웹 서비스에서 우아하게 비동기 처리하기/09.png">

- 우선 함수가 하는 일을 흐리게 만들던 if문 들이 사라져서 코드가 간결하다

- 덕분에 어떤 역할을 하는 함수 인지 한눈에 확인할 수 있다.

- 또 잘 살펴보면 Nullable 아닐 때,

- 즉 성공할 때 접근하는 모습을 나타내는 `x.foo.bar.baz` 라고 하는 표현 식과 모양이 큰 차이가 없는 것도 확인할 수 있다.

- 같은 역할을 하는 식이 비슷하게 표현된다는 것은 코드의 있어서 좋은 징조 중 하나이다

<br/>

- 다음으로 조금 더 복잡한 예제를 살펴보자

- 아래는 자바스크립트의 프로미스가 없던 시절 비동기 를 처리하기 위해 콜백을 사용한 코드이다.

<img src="./images/토스ㅣSLASH 21 - 프론트엔드 웹 서비스에서 우아하게 비동기 처리하기/04.png">

- 하는 일을 살펴면 `fetchUserEntity`를 호출해서 그 결과를 콜백 으로 받는데 에러가 있으면 에러를 emit 한다

- 그리고 그 결과 값을 이용해서 사용자의 계좌 목록을 가져오는데

- 마찬가지로 에러가 있으면 에러를 emit 하고 아니면 실제 값을 emit 한다

  - 즉, 위 코드는 `fetchUserEntity` 호출 후 에러가 있으면 `callback(err, null)`을 호출해서 끝내고

  - 아니면 `fetchUserAcoounts` 를 호출하는데 이 때도 만약 에러가 있으면 `callback(err, null)`을 호출해서 끝내게 된다.

  - 두 함수 호출시 에러가 없는 경우 `callback(null, accounts)`을 호출하게 되는 코드이다.

- 이 코드는 복잡하기도 하지만 또 다른 문제점도 있다

<img src="./images/토스ㅣSLASH 21 - 프론트엔드 웹 서비스에서 우아하게 비동기 처리하기/05.png">

- 우선 성공하는 경우와 실패하는 경우가 전혀 나뉘어 있지 않다.

- 이 함수가 하는 일은 결국 user를 가져오고 그 정보를 바탕으로 accounts를 가져오고 그 값을 반환하는 역할이라고 요약할 수 있는데 중간에 실패하는 경우에 대한 처리가 섞여서 함수가 하는 진짜 역할이 가려졌다

  - 그렇다면 위 코드에서 `accounts`가 아니라 `user.accounts` 가 아닐까 ?

- 또 코드를 작성하는 입장에서 매번 비동기 호출을 할 때마다 에러 처리를 해줘야 한다는 점이 불편한점 중 하나라고 말할 수 있다

- 아래 코드는 async-await 문법을 사용한 코드

<img src="./images/토스ㅣSLASH 21 - 프론트엔드 웹 서비스에서 우아하게 비동기 처리하기/06.png">

- 이전 코드에 비해 많이 간절해졌다.

- 이 코드가 좋은 코드라고 말할 수 있는 이유는 비동기 요청들이 성공하는 경우 들만 모아서 살펴볼 수 있다는 점이다.

<img src="./images/토스ㅣSLASH 21 - 프론트엔드 웹 서비스에서 우아하게 비동기 처리하기/07.png">

- 덕분에 함수가 하는 역할이 명확히 드러난다.

- 동기적인 코드와 큰 차이가 없다.

- 또 별도로 에러를 처리하는 부분이 없고 모든 에러 처리는 외부의 위임된다 라고 하는 점도 좋은 코드 임을 드러내는 부분 중 하나라고 생각한다

- 이 함수는 성공하는 부분만 책임지고 다른 경우는 외부의 더 잘할 수 있는 부분에 위임하는 것

- 물론 필요하다면 내부에서 `try-catch`로 처리할 수도 있다

<br/>

- 즉 지금까지 살펴보았던 좋은 코드의 특징은 다음과 같다

<img src="./images/토스ㅣSLASH 21 - 프론트엔드 웹 서비스에서 우아하게 비동기 처리하기/10.png">

- 성공하는 경우와 실패하는 경우를 분리해서 처리할 수 있다.

- 함수에는 성공하는 경우들만 적혀있으니 읽기도 쉽고 함수에 책임이 명확히 들어간다

- 반대로 읽기 어려운 코드들의 공통점을 꼽아 보자면 실패하는 경우와 성공하는 경우가 섞여서 처리 된다는 점이 있다

- 덕분에 함수에 크기가 커지고 하는 역할이 명시적으로 드러나지 못했다.

- 그렇다면 프론트엔드 웹 서비스에서 비동기 처리가 어땠는지 한번 되짚어 보자

- api 호출과 같은 상황을 처리할 때 리액트 사용하는 경우에는 보통 아래처럼 swr이나 React Query 같은 라이브러리를 활용해서 비동기를 처리한다

<img src="./images/토스ㅣSLASH 21 - 프론트엔드 웹 서비스에서 우아하게 비동기 처리하기/11.png">

- 프로미스를 반환하는 함수를 React Hook의 인자로 넘기고 프로미스의 상태 변화에 따라 Hook이 반환하는 data, error에 값을 적절히 채워주는 것

- 그리고 아래처럼 컴포넌트를 작성하고는 한다

<img src="./images/토스ㅣSLASH 21 - 프론트엔드 웹 서비스에서 우아하게 비동기 처리하기/12.png">

- 코드를 보면 비동기인 `foo`를 가져오는데 `foo`가 에러이면 실패 메시지를 보여주고

- `foo`가 없으면 "로딩 중" 이라고 보여주고,

- `foo`가 있으면 "안녕하세요" 라고 하는 메시지를 보여 준다.

- 그렇게 코드를 많이 작성한다

- 하지만 살펴보면 이전에 문제점들이 거의 그대로 나타나고 있다

- 우선 성공하는 경우와 실패하는 경우가 섞여서 처리되고 있고

- 실패하는 경우에 대한 처리를 외부에 위임 하기가 어려워졌다.

- 이런 문제는 여러 개의 비동기 작업이 동시에 실행될 때 더 심각해진다.

- 방금 전에 봤던 콜백 코드 와 비슷하게 코드가 점점 읽기 어려워지는 것

- 아래는 `foo`와 `bar`라고 하는 값을 비동기로 가져오는 코드로 `bar`를 가져오기 위해서는 `foo` 가 있어야 하는 상황이다.

<img src="./images/토스ㅣSLASH 21 - 프론트엔드 웹 서비스에서 우아하게 비동기 처리하기/13.png">

- 이것을 어떻게 구했는지 한번 살펴보면 `foo`를 가져오고 `bar`는 `foo`가 로드될 때까지 기다리고 if 문은 복잡해진다

- 보통은 하나의 비동기 작업은 로딩중, 에러, 완료 등 3가지 의 상태를 가지고 있다

<img src="./images/토스ㅣSLASH 21 - 프론트엔드 웹 서비스에서 우아하게 비동기 처리하기/14.png">

- 만약에 두 개의 비동기 작업이 있다면 3의 제곱으로 9가지의 상태를 가질 수 있다

- 그렇다면 비동기 호출이 3개, 4개 가 된다면 더욱 복잡해질 것

<br/>

- 이전에 살펴보았던 좋은 코드에 대한 생각으로 다시 돌아가 보자

- 만약에 리액트 컴포넌트가 아니라 일반적인 비동기 함수라면 어떻게 코딩 했을지에 대해 생각해보자

- 일반적인 비동기 코드는 요즘 `async-await` 스타일로 작성을 하는데 아래와 작성을 한다

<img src="./images/토스ㅣSLASH 21 - 프론트엔드 웹 서비스에서 우아하게 비동기 처리하기/15.png">

- 다시 살펴보면 성공하는 경우에만 집중하여 복잡도를 낮추고 일반적인 동기 로직과 큰 차이 없이 로직을 작성한다

- 리액트에서 지금까지 살펴보았던 hook이나 state를 사용하는 방식으로는 이렇게 간단히 비동기 처리를 할 수 없다.

- 그래서 리액트 에서 비동기처리가 어려웠다고 생각한다.

<img src="./images/토스ㅣSLASH 21 - 프론트엔드 웹 서비스에서 우아하게 비동기 처리하기/16.png">

- 특히 이 어려운 비동기처리는 두 가지 이상의 로직이 개입해서 복잡해 질 때 더욱 어려워진다.

- 다행 이 문제를 우아하게 해결해 주는 도구가 있다

<img src="./images/토스ㅣSLASH 21 - 프론트엔드 웹 서비스에서 우아하게 비동기 처리하기/17.png">

- 리액트 팀이 제안하는 "React Suspense for Data Fetching" 이다

- "React Suspense for Data Fetching"은 한국어로는 데이터를 가져오기 위한 Suspense 라고 할 수 있다.

- 아직은 react@experimental, 즉, 실험 버전에서만 사용할 수 있다

- "React Suspense for Data Fetching"이 목표로 하는 코드는 간단하다.

<img src="./images/토스ㅣSLASH 21 - 프론트엔드 웹 서비스에서 우아하게 비동기 처리하기/18.png">

- 쉽게 말해 `async-await` 급으로 비동기를 처리하면서 간단하고 읽기편한 리액트 컴포넌트를 만들겠다고 하는 것

- 다시 말해 컴포넌트는 성공한 상태만 다루고 로딩 상태와 에러 상태는 외부의 위임함으로써

- 동기적인 코드와 큰 차이가 없는 코드를 만들겠다는 비전이다.

<img src="./images/토스ㅣSLASH 21 - 프론트엔드 웹 서비스에서 우아하게 비동기 처리하기/19.png">

- 실제로 방금 `FooBar` 컴포넌트의 `useAsyncValue`를 동기인 계산을 하는 useMemo로 거의 그대로 치환 하면 완벽히 똑같은 구조를 가지고 있는 것을 확인할 수 있다

  - 즉, 로딩과 에러 처리가 컴포넌트 내부 로직에 더 이상 필요 없게 된다.

- "React Suspense for Data Fetching"은 이러한 `useAsyncValue` 같은 hook을 만들 수 있는 Low-level API를 제공한다

<img src="./images/토스ㅣSLASH 21 - 프론트엔드 웹 서비스에서 우아하게 비동기 처리하기/20.png">

- 만약에 비동기 작업을 저렇게 처리한다면 에러 상태나 로딩 상태는 어떻게 처리해야 할까

- 이는 간단한데 함수 에러 처리를 감싸는 catch문에서 하는 것처럼 로딩 상태와 에러처리도 컴포넌트를 쓰는 곳에서 해주면 된다

- 로딩 상태는 가장 가까운 Suspense의 fallback으로 그려지는 것

- 에러 상태도 비슷하게 ErrorBoundary가 처리해 주게 하면 된다.

<img src="./images/토스ㅣSLASH 21 - 프론트엔드 웹 서비스에서 우아하게 비동기 처리하기/21.png">

- `async-await`의 `try-catch` 문과

- 방금 작성한 `ErrorBoundary/Suspense`를 살펴보면 거의 유사한 구조를 가지고 있는 모습을 확인할 수 있다

- 비동기 콜을 하는 함수나 컴포넌트가 가운데 있고 실패하는 경우를 처리하는 부분이 그 부분을 감싸고 있다.

- 모든 실패할 수 있는 함수에 `try-catch`를 감싸지 않는 것처럼 Suspense 를 일으키는 모든 컴포넌트에 Suspense나 ErrorBoundary를 붙여 주기 보다는 적당한 부분 단위로 에러와 로딩 상태를 한번에 처리하게 된다.

- 예를 들어 아래에 있는 코드는 앱 전체에서 로딩 상태와 에러 상태를 처리해주는 핸들러를 선언한 것

<img src="./images/토스ㅣSLASH 21 - 프론트엔드 웹 서비스에서 우아하게 비동기 처리하기/22.png">

- 이렇게 비동기를 동기적으로 바꿔주는 Suspense 기능을 이용 하기는 어렵지 않다.

<img src="./images/토스ㅣSLASH 21 - 프론트엔드 웹 서비스에서 우아하게 비동기 처리하기/23.png">

- 사용하시는 라이브러리에서 Suspense 를 사용한다 라고 선언해 주면 되는데

- Recoil에서는 Async Selector라고 하는 기능이 있고

- SWR이나 React Query에서 는 `{suspense: true}` 라고 하는 옵션을 사용해 주면 된다.

- 이런 옵션을 사용한 이후에는 자동으로 컴포넌트의 Suspense 상태가 관리된다

- 이렇게 React Suspsne를 사용하면 로딩과 에러 처리를 바깥으로 위임하며 비동기 작업을 동지와 똑같이 처리할 수 있었는데

- 리액트 팀의 Sebastian이 만들었던 코드 스니펫 이런 마법이 어떻게 리액트 에서 구현되어 있는지 보여준다

<img src="./images/토스ㅣSLASH 21 - 프론트엔드 웹 서비스에서 우아하게 비동기 처리하기/24.png">

- 코드를 살펴 보면 `fetchTextSync` 라고 하는 함수는 원래 api 호출으로 비동기 작업이지만 동기처럼 사용되고 있는 걸 볼 수 있다.

- 이 모든 것을 가능해 주도록 하는 것은 `runPureTask` 라고 하는 런타임 인데 그 구현체는 아래 링크에서 확인할 수 있다

  - [참고 링크](https://gist.github.com/sebmarkbage/2c7acb6210266045050632ea611aebee)

<br/>

- 토스 팀에서는 최근에 개발된 서비스 일부를 리 엑트 서스펜스를 활용해서 마이그레이션을 진행하고 있다.

- 대표적으로 적용된 제품은 토스팀의 TUBA라고 하는 제품

<img src="./images/토스ㅣSLASH 21 - 프론트엔드 웹 서비스에서 우아하게 비동기 처리하기/25.png">

- TUBA 제품은 토스 대부분의 데이터가 모이고 분석되는 내부 제품인데

- 다양한 A/B 테스트를 설정하거나 알림이나 푸쉬를 전송하는 등 다양한 작업을 수행하고 있다

- 토스 앱에서 알림이나 푸쉬를 보낼 때 사용하는 제품이 바로 TUBA 메신저 인데

- TUBA 메신저의 메시지 상세 화면에서는 상당히 복잡한 비동기 처리가 필요했다

- api 호출로 가져와야 하는 부분들이 이렇게 다양 했는데

<img src="./images/토스ㅣSLASH 21 - 프론트엔드 웹 서비스에서 우아하게 비동기 처리하기/26.png">

- 어떤 메시지였는지 메시지의 내용이 뭔지, 발송 일정이 뭔지, 통계 정보가 어떻게 나왔는지등

- 이런 다양한 데이터를 복잡한 조건하에 가져와야 하는 니즈가 있었다.

- 이런 문제를 Recoil의 비동기 `selector`를 이용해서 해결할 수 있었는데

<img src="./images/토스ㅣSLASH 21 - 프론트엔드 웹 서비스에서 우아하게 비동기 처리하기/27.png">

- Recoil서는 비동기 리소스를 이렇게 `selector` 또는 `selectorFamily`로 정의할 수 있다

- 코드를 살펴 보면 `templateSetSelector`는 `no` 라고 하는 번호를 인자로 받아 `fetchTemplateSet` 하는 비동기 호출을 보내는 것을 볼 수 있다

- 이렇게 정의한 비동기 리소스를 `useRecoilValue`를 이용해서 가져오려고 하면 Suspense가 발생하게 된다.

<img src="./images/토스ㅣSLASH 21 - 프론트엔드 웹 서비스에서 우아하게 비동기 처리하기/28.png">

- 그리고 `useRecoilValue` 밑에서는 `templateSet`을 가져왔다는 것을 타입 적으로 완전히 보장할 수 있게 되었다.

- 이렇게 비동기 호출을 하는 컴포넌트를 적절히 서스펜스로 감싸 주기만 하면 된다.

- 원래 리덕스나 다른 도구들을 이용해서 처리했다면 굉장히 복잡해 했을 비동기 처리를 Recoil과 서스펜스를 이용해서 굉장히 간단하게 바꿀 수 있다.

<img src="./images/토스ㅣSLASH 21 - 프론트엔드 웹 서비스에서 우아하게 비동기 처리하기/29.png">

- 사용자 경험 측면에서 도 데이터가 준비 되는대로 하나씩 자연스럽게 보여줄 수 있었는데

- 동영상(17:00)을 보면 단계적으로 데이터가 준비되는 대로 계속 나타나는 것을 확인할 수 있다.

- 리액트 서스펜스 덕분에 많은 비동기적인 문제를 깔끔하고 우아하게 처리할 수가 있게 되었는데 코드의 복잡도 도 줄일 수 있다.

<br/>

<img src="./images/토스ㅣSLASH 21 - 프론트엔드 웹 서비스에서 우아하게 비동기 처리하기/30.png">

- 2년 반 정도 전에 나왔던 리액트 훅스는 이제 너무 익숙하지만 비슷한 역할을 해주고 있다

- 웹 서비스의 코드 복잡도를 줄이고 상태, 이펙트와 메모이제이션과 같이 자주 발생하는 작업들을 매우 쉽게 사용할 수 있게 해주었다

- 남은 부분에서는 Hooks와 서스펜스 를 비교하면서 어떤 유사점이 있는지 어떤 부분이 좋은 코드 작성을 도 왔는지 한번 살펴보려고 한다

<br/>

<img src="./images/토스ㅣSLASH 21 - 프론트엔드 웹 서비스에서 우아하게 비동기 처리하기/31.png">

- 리액트의 선언적인 api 가 코드 복잡도를 줄여주는데 큰 기여를 했다고 생각한다

- 이전에 클래스 컴포넌트에서는 컴포넌트의 라이프사이클에 맞춰 다양한 작업을 명령으로 해주어야 했지만

- hooks를 사용하면서 상황이 달라졌다.

- useState로 상태를 사용한다고 선언하고

- useMemo로 메모이제이션을 한다고 선언했다.

- useEffect로 효과를 발생시킨다고 선언했다.

- 그렇게 선언 하기만 하면 리액트 프레임워크가 실제 작업을 대신 해주었다

- 서스펜스도 비슷하다.

<img src="./images/토스ㅣSLASH 21 - 프론트엔드 웹 서비스에서 우아하게 비동기 처리하기/32.png">

- 컴포넌 에서는 비동기적인 리소스를 선언하고 그 값을 읽어 온다고 '선언' 하기만 한 것

- 그러면 실제 로딩 상태나 에러 상태 처리는 컴포넌트를 감싸는 부모 컴포넌트가 대신 해주었다

- 또 비슷한 것이 있는데 바로 `try-catch`문이다

<img src="./images/토스ㅣSLASH 21 - 프론트엔드 웹 서비스에서 우아하게 비동기 처리하기/33.png">

- 실패할 수 있는 함수는 throw 문으로 에러를 발생시키고 실제로 처리는 컴포넌트를 감싸는 부모 함수가 수행해 주는 것

  - `"컴포넌트를 감싸는 부모 함수"` 라는 부분이 잘 이해가 되지 않음

  - `함수를 감싸는 부모 함수가` 정확한 표현이 아닐까 싶다

<img src="./images/토스ㅣSLASH 21 - 프론트엔드 웹 서비스에서 우아하게 비동기 처리하기/34.png">

- 이렇게 어떤 코드 조각을 감싸는 맥락으로 책임을 분리하는 방식을 대수적 효과라고 한다

- 객체 지향의 의존성 주입(DI), 의존성 역전 원칙(IoC) 과도 유사한데

- 대수적 효과를 지원하는 언어에서 함수는 필요한 코드 조각을 선언적으로 사용한다

- 메모이제이션이 필요하면 useMemo를 호출하는 식

- 그러면 실제로 관련된 처리는 함수를 감싸는 부모 함수나 런타임이 처리하는 형식

- 혹시 더 자세한 내용이 궁그마다면 [참고 링크](https://overreacted.io/algebraic-effects-for-the-rest-of-us/)의 Dan Abramove 에 글을 참고

<img src="./images/토스ㅣSLASH 21 - 프론트엔드 웹 서비스에서 우아하게 비동기 처리하기/35.png">

- 시간 관계상 발표는 여기가 마지막이지만 소개하고 싶었지만 소개하지 못한

- 리액트에서 사용자 경험을 더욱 향상시킬 수 있는 다른 리액트 요소에 대한 키워드만 던지고 발표를 마무리 하려고 한다

- 바로 React Concurrent Mode와 useTransition, useDefferedValue

- 이 요소들을 사용한다면 리액트에서 컴포넌트의 렌더 트리를 부분적으로만 완성함으로써 사용자 경험을 크게 향상시킬 수 있다

- 비동기 작업 뿐만 아니라 기존의 Debounce 등으로 처리하던 무거운 동기적 작업에도 적용할 수 있는데

- 혹시 사용자 경험 향상에 관심이 있으시다면 꼭 한번 살펴볼것
