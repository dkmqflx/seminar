## 데코레이터 패턴 (decorator pattern)

- 이번 시간에는 데코레이터 패턴에 대해 이야기해보려고 하는데요

- 데코레이터는 기존의 동작을 유지하면서 기능을 추가하거나 확장할 때 유용한데

- 이름에서 느껴지는 바와 같이 주로 감싸는 형태, 즉 wrapper의 형태를 갖고 있어요

- 이런 방식으로 익숙하게는 고차함수(higher-order function)를 예로 들 수 있을 것 같은데요

<img src='./images/프론트엔드에 디자인패턴 끼얹기3 - 데코레이터 패턴 (decorator pattern)/01.png'>

- 위키 백과에 따르면 고차함수는 '하나 이상의 함수를 인자로 받거나, 함수를 결과로 반환하는 것' 이라고 정의하고있어요

<br/>

- 프론트엔드 개발자 입장에서 흔히 볼 수 있는 예시로는 debounce 함수를 들 수 있을 것 같아요

- debounce 함수는 특정 시간동안 중복된 실행이 있을 때 마지막 호출만 실행될 수 있도록 하는 역할을 하는데요

- 예를들어서 다음과 같은 형태로 구현된 코드는 input 창에 키워드가 변경될 때마다 검색이 수행되면서 매번 요청이 발생하는것을 볼 수 있는데

<img src='./images/프론트엔드에 디자인패턴 끼얹기3 - 데코레이터 패턴 (decorator pattern)/02.png'>

<br/>

- 여기서 다음과 같이 debounce 함수로 기존의 search 함수를 감싸주면 요청이 절약되도록 처리할 수 있고 이 형태를 search 함수가 debounce로 데코레이팅 되었다 라고 할 수 있을 것 같아요

<img src='./images/프론트엔드에 디자인패턴 끼얹기3 - 데코레이터 패턴 (decorator pattern)/03.png'>

<br/>

- 고차함수인 debounce는 다음과 같은 형태로 구현할 수 있을 것 같은데

<img src='./images/프론트엔드에 디자인패턴 끼얹기3 - 데코레이터 패턴 (decorator pattern)/04.png'>

- 고차 함수를 이용해 반환된 내부 함수가 closure 영역의 timer id를 참조하면서 특정 시간 내에 중복된 실행이 있을때 기존 실행을 무효화하고

- 추가 지연시키는 행위를 하면서도 결론적으로는 인자로 주입된 함수를 실행하게 되는데요

<br/>

- 이런 형태를 사용해서 특정 로직을 수행하는 함수들에 로깅을 하거나, 검증 로직을 데코레이팅하는 식으로 관점 지향 프로그래밍(AOP)스러운 설계를 해볼 수 있을 것 같아요

<img src='./images/프론트엔드에 디자인패턴 끼얹기3 - 데코레이터 패턴 (decorator pattern)/05.png'>

<br/>

- 좀 덧붙이면 babel이나 typescript 등의 환경을 사용하면 아래와 같은 형태로 class 내부에서 골뱅이(at sign)를 사용하여 데코레이터를 문법적으로 지원받을 수 있는데

<img src='./images/프론트엔드에 디자인패턴 끼얹기3 - 데코레이터 패턴 (decorator pattern)/06.png'>

- class 형태의 구현을 사용하신다면 고차 함수를 정의하고 데코레이터를 덧붙이는 것으로 편리하게 로직을 관리할 수 있다는 점을 한 번 짚고 넘어가고 이를 응용하는 영역은 여러분의 상상력에 맡기도록 할게요

<br/>

- 자 그럼 여기서 한 가지 더 생각해봐야할 점으로 react 개발자가 가장 흔하게 다루는 함수는 무엇일까요?

- 네 그건 바로 component 인데요 아마 이미 떠올리신 분들도 계시겠지만 우리가 흔하게 사용하는 데코레이터 패턴 중에 하나로 고차 컴포넌트(higher-order component)를 예로 들 수 있을 것 같아요

- 흔히 알려진 예시로는 로그인 여부에 따라 조건부 랜더링을 하는 컴포넌트를 반환하는 함수를 다음과 같은 형태로 구현하고

<img src='./images/프론트엔드에 디자인패턴 끼얹기3 - 데코레이터 패턴 (decorator pattern)/07.png'>

- 특정 컴포넌트를 감싸서 로그인 여부에 따라 보여줄지 말지에 대한 기능을 적용할 수 있는데 결국 이 또한 데코레이터 패턴이라고 볼 수 있을 것 같아요

- 개인적으로는 고차 컴포넌트를 사용했을때 발생하는 안티 패턴을 최소화하기 위해서

- 이렇게 함수로 직접 래핑해서 제공하는 것보다는 별개의 컴포넌트 형태로 데코레이팅 하는것을 선호하기도 합니다

<img src='./images/프론트엔드에 디자인패턴 끼얹기3 - 데코레이터 패턴 (decorator pattern)/08.png'>

<br/>

- 그리고 약간 오버스럽지만 swr이나 react query 등을 사용해서 data fetching을 하는 페이지가 있다고 가정했을때

<img src='./images/프론트엔드에 디자인패턴 끼얹기3 - 데코레이터 패턴 (decorator pattern)/09.png'>

- 여기에 그대로 suspense 옵션을 사용할 경우 상위 레벨로 전파가 되어서 페이지 전체에 영향을 끼치게 되는데요

- 이를 목록만 대상으로 suspense를 적용하고 싶다면 별도의 컴포넌트로 분리해야하고 컴포넌트 분리로 depth가 깊어지면 의존관계에 따라서 props를 매번 신경써줘야한다던가

- 하위 컴포넌트에 대한 제어가 어려워지는 등의 번거로움이 생길 수 있어요

<img src='./images/프론트엔드에 디자인패턴 끼얹기3 - 데코레이터 패턴 (decorator pattern)/10.png'>

<br/>

- 이때 Suspense 컴포넌트를 래핑해서 children을 익명함수 형태로 사용할 수 있는 간단한 데코레이터를 정의하고 별도의 컴포넌트 분리 없이 편리한 상호작용이 가능하도록 구현할 수 있는데요

<img src='./images/프론트엔드에 디자인패턴 끼얹기3 - 데코레이터 패턴 (decorator pattern)/11.png'>

- 물론 고수 형님들이 이 형태를 보면

  - '이건 컴포넌트 내에서 정의해서 사용해도 같지 않냐?'

  - '리렌더링은 어떻게 할거냐' 라고 불편해 하실수도 있는데

- 상태와 로직이 명확히 구분되어있는 설계를 기반으로 사용하게되면 포넌트를 인지하는 흐름이 꽤 직관적인 부분도 있어서 굿 케이스와 안티 패턴을 실험하고 있어요

- 이에 대해 유의미한 결과가 나온다면 다음 기회에 소개해보도록 하겠습니다

- 이번 영상에서는 데코레이터 패턴에 고차 컴포넌트를 섞어서 간단하게(?) 이야기 해봤는데요

- 영상에서 언급하진 않았지만 특히 동적 언어에서 프록시 패턴과 데코레이터 패턴이 경계가 모호한 부분이 있는데

- 이 부분도 추후에 다뤄보도록 하고

- 늘 그렇듯 아이디어를 어디에 어떻게 적용할지는 여러분의 상상력에 맡기며 퇴장해보도록 하겠습니다

---

## Reference

- [프론트엔드에 디자인패턴 끼얹기3 - 데코레이터 패턴 (decorator pattern)](https://www.youtube.com/watch?v=PU9sr-q8bys&t=193s)
