## Docker(도커)

- 도커란 어플리케이션을 패키징 할 수 있는 툴

<img src='./images/도커 한방에 정리  (모든 개발자들이 배워보고 싶어 하는 툴!) + 실습/01.png'>

- 컨테이너라고 불리는 하나의 작은 소프트웨어 유닛 안에 우리 어플리케이션과 그에 필요한 시스템 틀, 환경 설정, 모든 디펜더시를 하나로 묶어서 다른 서버, 다른 pc 그 어떤 곳에도 쉽게 배포하고 안정적으로 구동할 수 있게 도와주는 툴이라고 생각합니다.

<br/>

<img src='./images/도커 한방에 정리  (모든 개발자들이 배워보고 싶어 하는 툴!) + 실습/02.png'>

- 테크놀로지가 발전함에 따라서 우리 어플리케이션을 구동하는데 꽤 많은 것들이 필요해 졌습니다

- 노드 js를 예를 들어 보면, 우리의 소스 파일만 서버에 배포하는 것으로는 우리 어플리케이션을 구동하는데 문제점이 있습니다

- 노드 js 와 npm 외부 라이브러리를 사용 한다면 여러 디펜던시와 그리고 환경 설정 하는 것 환경변수 이런 모든 것들을 다 설정을 해줘야 되는데요

- 서버 마다, 개발하는 개발자들이 pc 마다 이런 모든 것들을 설치하고 설정하는 것은 번거롭고 오류도 많이 발생할 수 있습니다

<br/>

<img src='./images/도커 한방에 정리  (모든 개발자들이 배워보고 싶어 하는 툴!) + 실습/03.png'>

- 내가 노드js를 가지고 있고 아 서버에도 노드js 가 있으니까 소스코드를 서버에 배포하면 자동으로 동작하겠지 라고 생각하다가는 에러가 발생할 수 있다는 거죠

- 내 pc 에서는 잘 되는데 웹서버에서는 안 되는 거지라고 디버깅을 하다보면 노드 js 버전이 맞지 않아서 발생하는 문제일 경우도 있습니다

<br/>

<img src='./images/도커 한방에 정리  (모든 개발자들이 배워보고 싶어 하는 툴!) + 실습/04.png'>

- 자 이런 번거로움 문제점을 해결해 주기 위해서 도커가 탄생 했는데요

- 이 도커 컨테이너 안에는 우리 어플리케이션 뿐만 아니라 우리 어플리케이션을 정상적으로 동작하기 위한 노드 js 환경 설정, npm 그리고 여러 라이브러리와 이들의 디펜던시 그리고 어플리케이션에 필요한 다양한 리소스 들이 포함될 수 있습니다

- 한마디로 얘기하면 우리 어플리케이션의 구동하는데 필요한 모든 것들을 이 도커 컨테이너 안에 담아 넣었다 라고 볼 수 있겠죠

<br/>

<img src='./images/도커 한방에 정리  (모든 개발자들이 배워보고 싶어 하는 툴!) + 실습/05.png'>

- 이렇게 도커 컨테이너를 사용하면 어플리케이션을 구동하기 위한 이 런타임 환경에 필요한 모든 것들을 어떤 pc 에서도 언제든지 동일하게 구동할 수 있고요

- 내 pc 에서는 잘 동작하는데 왜 니 서버 에서는 안되니라는 문제를 해결할 수 있습니다.

- 또 이것저것 설정하고 준비해야 되는 번거로움을 해결해 주는 정말 짱 유용한 패키징 툴이 라고 볼 수 있습니다

<br/>

<img src='./images/도커 한방에 정리  (모든 개발자들이 배워보고 싶어 하는 툴!) + 실습/06.png'>

- 자 이쯤 되면 그럼 도커 컨테이너가 Virtual Machine 과 비슷한 거 아닌가요 라고 질문해 주실 수 있을 것 같은데요

- vm은 요 하드웨어 Infrastructure 위에 vmware나 VirtualBox와 같은 이런 Hypervisor 같은 소프트웨어를 이용해서 요 각각의 가상의 머신을 만들 수 있습니다

- 한 운영체제 위에서 동일한 어플리케이션을 각각의 고립된 다른 환경에서 구동하기 위해서는 이 VM을 이용해서 어플리케이션을 구동 해야 했습니다

- 이 VM은 각각의 운영체제를 포함하고 있기 때문에 맥이라는 os 위에서 VM을 이용하면 윈도와 리눅스를 동시에 구동할 수 있습니다

- 이렇게 고립된 환경에서 어플리케이션을 구동하기 위해서 vm을 사용하면 운영체제를 포함하고 있기 때문에 굉장히 무겁고요

- 그리고 시작하는 데도 오래 걸리고 또 컴퓨터 운영체제 InfraStructure의 리소스를 많이 잡아먹는 범인이 될 수도 있어요

<br/>

<img src='./images/도커 한방에 정리  (모든 개발자들이 배워보고 싶어 하는 툴!) + 실습/07.png'>

- vm 에서 조금 경량화된 컨셉이 컨테이너 입니다

- 컨테이너는 이 하드웨어에 설치된 운영체제 즉, 호스트 os 에서 컨테이너 엔진이라는 소프트웨어를 설치만 하면 개별적인 컨테이너를 만들어서 이 각각의 어플리케이션을 고립된 환경에서 구동할 수 있게 해줍니다

- vm과의 차이점이 보이시죠

- vm은 운영체제를 포함했다면 이 컨테이너는 운영체제를 포함하지 않고 이 컨테이너 엔진의 설치된 호스트 os 를 공유 합니다

- 이것이 어떻게 가능한지에 대해서 얘기를 하려면 운영체제와 커널의 대해서 조금 깊숙하게 다뤄야 하므로 이번 영상에서는 그 부분은 좀 스킵을 하고요

- 자 다만 컨테이너가 구동되기 위해서는 이 컨테이너 엔진이라는 것이 필요하고요

- 이 컨테이너 엔진이 호스트 os에 접근해서 필요한 것들을 처리해 준다고 보면 될거 같습니다

- 그리고 이 컨테이너 엔진 중에 가장 많이 사랑받고 이용되는 것이 바로 도커라는 거죠

- 컨테이너는 정말 가벼워요

<br/>

## 도커의 동작 순서

- 그렇다면 이제 도커란 무엇인지 도커는 어떻게 구상 되어져 있는지 동작하는 순서에 대해서 얘기를 해볼게요

- 이 도커의 큰 그림을 바라보면 바로 컨테이너를 만들고 배포하고 구동 한다라고 이해하시면 되는데요

<br/>

<img src='./images/도커 한방에 정리  (모든 개발자들이 배워보고 싶어 하는 툴!) + 실습/08.png'>

- 이 컨테이너를 만들기 위해서는 총 세 가지가 필요합니다

- 컨테이너를 만들기 위해서는 먼저 도커 파일을 만들어야 되구요

- 이걸 이용해서 이미지를 만들어서 컨테이너를 구동할 수 있습니다

<br/>

<img src='./images/도커 한방에 정리  (모든 개발자들이 배워보고 싶어 하는 툴!) + 실습/09.png'>

- 제일 첫번째 단계의 도커 파일은 컨테이너를 어떻게 만들어야 하는지 설명서 또는 요리로 치면 레시피 같은 건데요

- 우리 어플리케이션을 구동하기 위해서 꼭 필요한 파일들은 무엇이 있는지 어떤 프레임워크나 라이브러리를 설치해야 되는지 외부 디펜더 씨에 대해서 명시할 수 있고요

- 그리고 필요한 환경 변수에 대해서 설정할 수도 있고 어떻게 구동 해야되는지 스크립트도 포함 할 수 있습니다

<br/>

- 이렇게 작성한 도커 파일을 이용해서 이미지를 만들 수 있는데요

<img src='./images/도커 한방에 정리  (모든 개발자들이 배워보고 싶어 하는 툴!) + 실습/10.png'>

- 이 이미지 안에는 우리 어플리케이션을 실행하는 데 필요한 코드 런타임 환경, 시스템 툴, 시스템 라이브러리 모든 세팅 들이 포함되어 있습니다

- 한마디로 얘기하면 실행되고 있는 우리 어플리케이션의 상태를 찰깍 스냅샷해서 이미지로 만들어 둔다 라고 생각하면 좋을 것 같은데요

- 이렇게 만들어진 이미지는 변경이 불가능한 불변의 상태로 볼 수 있습니다

<br/>

<img src='./images/도커 한방에 정리  (모든 개발자들이 배워보고 싶어 하는 툴!) + 실습/11.png'>

- 자 그리고 마지막 단계인 컨테이너 인데요

- 이 컨테이너는 샌드박스처럼 우리가 잘 캡쳐해 둔 우리 어플리케이션의 이미지를 고립된 환경에서 개별적인 그 파일 시스템 안에서 실행할 수 있는 것을 말합니다

- 컨테이너 안에서 우리 어플리케이션이 동작한다 라고 볼 수 있을 것 같은데요

- 컨테이너는 우리가 준비한 어플리케이션을 착각 스냅샷한 이미지를 이용해서 어플리케이션을 구동하게 되는 거죠

<br/>

<img src='./images/도커 한방에 정리  (모든 개발자들이 배워보고 싶어 하는 툴!) + 실습/12.png'>

- 객체지향 프로그래밍의 익숙하신 분들은 이 이미지를 클래스라고 생각하시면 될 것 같아요

- 동작하고 있는 어플리케이션을 스냅샷 해서 템플릿 형태로 이미지를 만들어 두고요

- 이 클래스 이미지를 이용해서 실제로 어플리케이션이 동작하는 각각의 컨테이너를 만들 수 있습니다

- 그래서 이미지는 우리가 캡쳐했을 당시 그 프로젝트 상태를 불변의 상태를 가지고 있구요

- 컨테이너에서 각각 동작하는 어플리케이션은 뭐 파일도 만들 수 있고 수정할 수도 있고 개별적으로 설정이 가능한 상태라고 보시면 되고

- 각각의 컨테이너에서 수정된 그런 파일들이 있다면 우리 이미지에는 전혀 영향을 끼치지 않아요

- 이미지는 클래스 그리고 각각의 컨테이너는 만들어진 인스턴스라고 볼 수 있을 것 같습니다

<br/>

## Shipping Containers

<img src='./images/도커 한방에 정리  (모든 개발자들이 배워보고 싶어 하는 툴!) + 실습/13.png'>

- 깃과 깃허브를 사용해 보셨다면 정말 익숙하실 텐데요

- 내 로컬 머신에서 이미지를 만들어서 깃허브와 같은 컨테이너 레지스트리 라는 곳에 내가 만든 이미지를 푸시를 하고

- 필요한 서버 그리고 다른 개발자 pc에서 내가 만들어 둔 이미지를 가지고 와서 그걸 그대로 실행하면 됩니다

- 물론 이미지를 정상적으로 실행하기 위해서는 도커와 같은 컨테이너 엔진을 꼭 설치해 두어야 합니다

<br/>

<img src='./images/도커 한방에 정리  (모든 개발자들이 배워보고 싶어 하는 툴!) + 실습/14.png'>

- 우리가 이미지를 업로드할 수 있는, 공유할 수 있는 컨테이너 레지스트리는 퍼블릭과 프라이빗이 있는데요

- 퍼블릭에는 dockerhub나 RED HAT, Github Pacakges와 같은 것들이 있구요

- 깃허브에서 패키지가 나온지 얼마 안 됐고 도커 허브가 더 많이 사용되어지고 있습니다

- 많은 개발자들은 이 퍼블릭 서비스를 이용하고 있지만 회사에서는 대부분 프라이빗을 사용합니다

- 우리회사 프로젝트에서 일하지 않는 다른 사람들이 우리 프로젝트 도커 이미지를 다운로드를 쉽게 받지 못하도록 보안적인 이유에서 이런 서비스를 사용하고 있는데요

- 구글 클라우드 및 주요 3사에서 이런 더 컨테이너 레지스트리와 같은 서비스를 제공해 주기 때문에 이것들을 사용하고 있어요

<br/>

<img src='./images/도커 한방에 정리  (모든 개발자들이 배워보고 싶어 하는 툴!) + 실습/15.png'>

- 자 마지막 총정리

- 우리가 개발하고 있는 로컬 머신에 도커를 설치하고

- 그리고 서버에도 도커를 설치하고

- 첫번째로는 우리 어플리케이션을 구동하는데 필요한 도커 파일을 작성한 다음에 이걸 이용해서 우리 어플리케이션을 스냅샷 할 수 있는 이미지를 만들고요

- 이 이미지를 컨테이너 레지스트리에 올린 다음에 서버에서 다운로드드 받아서 컨테이너를 실행할 수 있습니다

---

- 제일 처음에는 항상 FROM 베이스 이미지로 시작해야 합니다.

- 도커 이미지를 만들 때 처음부터 모든걸 다 우리가 만드는 게 아니라 베이스 이미지를 가지고 갑니다

- 노드에서 미리 만들어둔 노드 이미지가 있어요 이제 이걸 이용할 거구요

- 여기 노드 다음에 16 이라는 것은 노드 버전을 말하고

- 요 알파인 같은 경우는 정말 최소 단위, 작은 단위의 리눅스 버전을 말합니다

```shell

FROM node:16-alpine
# 어떤 베이스 이미지를 사용할 것인지 명시

```

- 어떤 베이스 이미지를 사용할 건지 명시를 했다면 도커 이미지 안에서,

- 컨테이너 안에서 어떤 경로에 우리가 이걸 실행 할 건지를 명시 해줘야 하는데요

- 바로 WORKDIR 라는 명령어를 이용해서 루트 경로의 app 이라는 폴더 안에서

- 우리 프로젝트에 관련된 모든 파일들을 카피해오겠다고 명시해 줄 수 있습니다

- WORKDIR은 유닉스 명령어 에서 cd 와 같은 개념

```shell

# 어떤 베이스 이미지를 사용할 것인지 명시
FROM node:16-alpine


# 어떤 디렉토리에 우리 어플리케이션을 복사해올 건지 명시
WORKDIR /app

```

- 다음으로는 우리 프로젝트 파일들을 복사해 와야 됩니다

- 그런데 여기서 꿀팁 있는데요, 도커 파일에서 이렇게 카피해 오고 명령을 수행하는 것은 레이어 시스템으로 구성이 되어져 있기 때문에

- 빈번히 변경되는 파일일수록 제일 마지막에 작성해 주는 게 좋아요

- 레이어 시스템에 대해서는 조금 이따가 다시 설명해 드릴게요

```shell
# https://github.com/dream-ellie/docker-example/commit/4ce7854c5ff90cf1509e5f5ac06ca118882ae412


# 어떤 베이스 이미지를 사용할 것인지 명시
FROM node:16-alpine


# 어떤 디렉토리에 우리 어플리케이션을 복사해올 건지 명시
WORKDIR /app


# package.json 을 현재 경로에 복사하는 명령어를 작성
COPY package.json package-lock.json ./
```

- 그럼 우리 프로젝트에서 소스 코드를 담고 있는 index.js가

- 다른 디펜던시에 대한 정보를 담고 있는 package.json 보다는 더 많이 빈번히 변경되겠죠

- 그렇기 때문에 이 package.json 을 먼저 복사해 오는 명령어를 작성하고 제일 마지막에 소스 파일을 복사해 오도록 할 거에요

- 그 다음 RUN 명령어를 실행해서 npm install을 해준다

- 그러면 모든 package.json에 명시되어 있는 모든 라이브러리를 설치할 수 있게 된다.

```shell

# https://github.com/dream-ellie/docker-example/commit/4ce7854c5ff90cf1509e5f5ac06ca118882ae412


# 어떤 베이스 이미지를 사용할 것인지 명시
FROM node:16-alpine


# 어떤 디렉토리에 우리 어플리케이션을 복사해올 건지 명시
WORKDIR /app


# package.json 을 현재 경로에 복사하는 명령어를 작성
COPY package.json package-lock.json ./


RUN npm ci
```

- 이때 정말 꿀팁 있는데요, npm install 대신에 npm ci 를 사용하는게 더 좋아요

- npm install 명령어는, 예를들어 특정 라이브러리의 버전 3이상은 괜찮다 라고 명시를 해두면

- 이걸 실행하는 당시의 최신 버전 5가 나왔다면 버전 5를 설치할 거에요

- 그래서 내가 프로젝트를 개발한 버전과 실제로 설치한 버전이 조금 달라질 수 있는 문제점이 있기 때문에

- 이 ci 를 사용하면 package-lock.json의 명시 되어져 있는

- 즉, 우리가 개발할 때 썻던 정확한 3.1.1 이런 버전을 고대로 설치하기 때문에 버전이 조금 달라지는 것에 대한 문제점을 해결할 수 있어요

<br/>

- 자 마지막 우리 소스 파일을 카피해 온 다음에 이제 드디어 실행하면 됩니다

- 바로 ENTRYPOINT 라는 명령어를 이용해서 노드 라는 걸 실행 할 거고 index.js 파일을 실행해 라고 명시해 주면 됩니다

```shell

# https://github.com/dream-ellie/docker-example/commit/4ce7854c5ff90cf1509e5f5ac06ca118882ae412


# 어떤 베이스 이미지를 사용할 것인지 명시
FROM node:16-alpine


# 어떤 디렉토리에 우리 어플리케이션을 복사해올 건지 명시
WORKDIR /app


# package.json 을 현재 경로에 복사하는 명령어를 작성
COPY package.json package-lock.json ./

RUN npm ci

COPY index.js .

ENTRYPOINT [ "node", "index.js" ]

```

<br/>

- 제일 처음 단계인 도커 파일을 만들어 보았습니다 생각보다 어렵지 않았죠

<img src='./images/도커 한방에 정리  (모든 개발자들이 배워보고 싶어 하는 툴!) + 실습/16.png'>

- 이렇게 도커 파일은 레이어 형태로 작성해 주는게 좋은데요

- 제일 빈번히 발생하는 것일 수록 제일 마지막에 작성해야 됩니다

- 이렇게 명령어 하나하나가 레이어로 되어 있어서 가장 빈번히 변경되는 걸 제일 나중에 적으면 레이어 제일 위쪽으로 위치가 되기 때문에

- 이미지를 만들고 나중에 소스 파일이 변경되어서 새로운 이미지를 만들어 낼 때

- 이렇게 레이어를 제일 위쪽에 위치해 두게 되면 변경된 최상단의 레이어만 업데이트 해주고 나머지 레이어는 다시 만들지 않아도 됩니다

- 그래서 이미지를 다시 만들 때 변경 되지 않은 레이어 까지는 재사용, 캐시된 걸 사용하고

- 변경된 레이어 부터 그 위에 있는 것까지는 다시 빌드를 하기 때문에

- 이미지를 만드는 시간을 단축할 수 있고요 또 효율성도 높아지겠죠

<br/>

- 여기까지 도커 파일을 작성 해 보았구요 이제 이걸 이용해서 이미지를 만들어 볼까요

- 자 설치한 도커를 이용해서도 docker build라는 명령어를 이용할 수 있고요 요렇게 작성할 수 있습니다

```shell
$ docker build -f Dockerfile -t fund-docker .
```

- 하나씩 뜯어보면요 제일 마지막에 `.`은 빌드 컨텍스트 라고 불리는건데,

- 도커에게 필요한 파일은 여기에 있어라는 것을 알려줍니다

- 현재 최상위 경로에 우리의 도커 파일이 있기 때문에 지금 명령어를 수행하는 현재 경로를 지정해주고

- `-f` 옵션 은 어떤 도커 파일을 사용할 건지 명시해 줄 수 있습니다

- 기본적으로 여기서는 Dockerfile이라고 작성 하지만 다른 이름을 지정해 줄 수도 있거든요

- `-t` 옵션을 이용하면 도커 이미지의 이름을 부여할 수 있습니다

- 태그 같은 개념

<br/>

- 앞에서 작성한 명령어를 실행해 보면 우리가 도커 파일에서 명시한 명령어가 순차적으로 실행된 것을 터미널에서 확인할 수 있다.

- `docker images` 라는 명령어를 실행하면 우리 로컬 머신에 만들어진 이미지들을 확인할 수 있습니다

```shell

REPOSITORY TAG

fun-docker latest

```

- 아까 이미지를 만들 때 이미지 이름을 fun-docker 라고 했는데요

- 여기에 REPOSITORY 필드 안에 fun-docker 라고 되어있어요

- 깃허브와 비교하면 레포지토리와 동일한데요

- 나중에 컨테이너 레지스트리에 올릴 때 이 이름이 재사용 될 거에요

- 그리고 이미지 버전을 따로 명세 주지 않아서 그냥 최신 버전인 latest가 지정되어 있는 걸 볼 수 있습니다

- 여기까지 거의 다 왔습니다 도커 파일을 이용해서 우리가 도커 이미지를 만들었구요

- 자 이제는 이 이미지를 이용해서 컨테이너를 실행해 보도록 할 꺼예요

- `docker run` 라는 명령을 이용해서 실행할 수 있고요

- 자 이렇게 작성하면 되는데

```shell

$ docker run -d -p 8080:8080 fun-docker

```

- `-d` 옵션은 detached를 의미합니다

  - to run a container in a background

- 백그라운드 에서 우리 도커가 동작해야 하므로

- 왜냐하면 노드 js 백엔드 어플리케이션 이기 때문에

- 백그라운드 에서 계속 동작해야 되는데 그러면 터미널이 계속 기다려야 겠죠

- 그래서 이 명령을 수행하고 터미널 내가 끝날 때까지 기다리지 말고 넌 니가 하는 일해,

- detach 좀 해 줘 라고 해서 -d 옵션 해주고요

- 그리고 `-p` 옵션을 이용해서 포트를 지정해 줍니다

  - `-p` is port publishing

  - maps a port on the container to a port on the host

- 즉, 호스트 머신 의 포트 8080 과 이 컨테이너 포트를 연결해 주는 작업을 해요

<img src='./images/도커 한방에 정리  (모든 개발자들이 배워보고 싶어 하는 툴!) + 실습/17.png'>

- 이 각각의 컨테이너는 개별적인 고립된 환경에서 동작하고 있으므로 이 호스트 머신에 있는 포트와

- 우리 컨테이너 있는 포트를 연결해 주는 작업을 해야 됩니다

- 명령을 실행하면 컨테이너가 동작하면서 컨테이너의 아이디가 프린트 되는 걸 볼 수 있습니다

- `docker ps` 라는 명령을 이용하면 현재 실행중인 컨테이너들의 리스트를 확인해 볼 수 있는데요

- 그러면 우린 도커 어플리케이션이 잘 동작하는지 확인하기 위해서 브라우저에서 `localhost:8080`에 접속하면 제대로 동작하는 것을 확인할 수 있어요

- 여기까지 도커 파일 만들고 이미지 만들어서 그리고 컨테이너를 실행하는 것 까지 해 봤고요

- 동작하고 있는 컨테이너에 대해서 로그나 다양한 정보들을 확인하고 싶다면 컨테이너가 실행할때 부여된 컨테이너 id 를 이용해서

- 명령어를 아래와 같이 실행하면 됩니다

```shell

$ docker logs "컨테이너 id"
```

- 이렇게 터미널을 사용하는게 익숙하지 않다면 우리가 설치했던 도 커 데스크탑 ui 를 이용해서 확인해 볼 수 있습니다

<br/>

- 자 드디어 마지막으로 우리 여정의 끝 마무리 컨테이너 레지스트리 우리의 이미지를 올려 봐야 겠죠

- 도커 허브를 사용해서 한번 해 볼텐데요

---

## Reference

- [도커 한방에 정리 🐳 (모든 개발자들이 배워보고 싶어 하는 툴!) + 실습](https://www.youtube.com/watch?v=LXJhA3VWXFA)

- [docker-example](https://github.com/dream-ellie/docker-example)

- [Docker Reference](https://github.com/dream-ellie/docker-example)

- [Overview of best practices for writing Dockerfiles](https://docs.docker.com/develop/develop-images/dockerfile_best-practices/)
