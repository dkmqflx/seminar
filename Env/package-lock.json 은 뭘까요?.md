- 자바스크립트로 프론트엔드나 백엔드 개발을 하신다면, 프로젝트에 이런 package-lock 파일이나 yarn.lock 파일이 포함되어 있는걸 보셨을겁니다.

- 다른 코드들과 다르게 프로그래머가 관리할 필요가 없고 npm이나 yarn과 같은 패키지 매니저가 알아서 관리해주는 그런 파일들이죠.

- 있으니까 그냥 놔두는데 정확히 어떤 용도인지는 모르시겠다면 지금 제 영상을 잘 봐주시면 되겠습니다.

<br/>

- 꼭 자바스크립트 뿐만 아니라 이제 현대적인 언어라면 보통 권장되는 패키지 매니저 하나쯤은 다 가지고 있기 마련입니다.

- 자바스크립트, Node.js에 npm이 있다면 Rust에는 Cargo, Go에는 dep이 있죠. 오히려 자바스크립트가 조금 특이한 경우인데 기본값으로 npm이 있는데도 은근 다른 대안이 되는 패키지 매니저를 많이들 씁니다.

- 윈도우즈 깔면 있는 인터넷 익스플로러처럼 기본적으로 Node.js를 설치하면 npm도 보통 같이 설치가 되는데요. 그런데도 여러 이유로, yarn이나 pnpm같은 다른 대안이 되는 패키지 매니저를 쓰고 있는 개발자들도 많습니다.

- 왜 이럴까에 대해서는 재미있을만한게 조금 있지만, 나중에 기회가 되면 한 번 이야기해볼까 합니다.

- 다시 돌아와서, 아까 방금, 현대적인 언어라면 패키지 매니저 하나쯤은 다 가지고 있다고 말씀드렸죠?

- 사실 여기에, 하나 더 추가해야합니다. 그게 바로, package-lock 같은 lock 파일입니다.

- 이 lock 파일은, 해당 프로젝트에 설치한 패키지, 그리고 그 패키지와 관련된 모든 패키지들의 버전 정보를 포함합니다.

- 이게 무슨 말이냐면요 여러분의 프로젝트가 이렇게 패키지 두개를 가져다가 쓰고 있다고 가정해보시죠.

  ```shell
  $ npm install --save @package/A @package/B

   @package/A => version 1.0
   @package/B => version 2.1

  ```

- 이렇게 패키지 A와 B를 설치했습니다.

- A는 버전 1.0, B는 버전 2.1이네요.

- package.json 파일에 두 패키지의 버전 정보가 잘 기록이 되어있게 되겠습니다.

- 그럼 이제, 이걸 다른 개발자가 받아가지고 실행을 시켜보려 합니다.

- 그러면 소스코드를 받아서, npm install을 실행을 하겠죠.

- 그럼 다른 개발자도 동일하게 패키지 A는 1.0 버전을, 패키지 B는 2.1 버전을 설치하게 될겁니다.

- 이러면 충분할까요? 충분할 수도 있지만 아닐 수도 있습니다.

- 보통 개발하다보면은 흔히 겪을 수 있는 문제들 있죠?

- 아까 버전 정보에서 뭐가 부족했을까요?

- 그건 바로 패키지 A와 B의 버전 정보는 지정을 했지만, A와 B가 **가지고 있는 패키지**의 버전은 지정하지 않았다는겁니다.

- 패키지 A가 사실은 C라는 패키지를 포함하고 있다고 해보겠습니다.

  ```shell
  $ npm install --save @package/A @package/B

   @package/A => version 1.0
       @package/C => version *
   @package/B => version 2.1

  ```

- 그런데 패키지 A에서 패키지 C의 버전을 명시를 안했네요?

- 그냥 별표로 두고 아무거나 깔라고 합니다.

- 여러분이 처음 세팅할 때는 패키지 C를 버전 1.0 짜리를 설치하고 동료 개발자는 2.0을 설치하고 하는 경우가 발생할 수 있다는 뜻입니다.

- 그런데 여러분이 처음 설치할 때 lock 파일을 만들고 거기서 패키지 C를 1.0으로 설치했다고 기록을 해두셨다면, 그렇게 꼬일 일이 발생하지 않게 되겠죠?

- package-lock 파일은 이렇게 관련된 패키지 버전들을 자동으로 관리하는 역할을 합니다. 훌륭하죠?

- 이렇게 개발환경이 좋아지고, 조금만 더 이야기를 해보겠습니다.

- 이런 패키지들을 데이터 구조에 비유를 한다면 뭐가 적절할까요?

- 뭐가 됐건 그래프이긴 할겁니다.

- 여러분과 제가 모두 인간이라는 같은 종에 속해 있는 것처럼 package-lock 파일도 그래프 구조에 속해 있을 테니까요

- 좀 더 좁혀보는게 좋겠죠? 일단 한가지 생각해보시죠 그래프 구조라고 할 때, 각 패키지를 노드 그리고 패키지가 다른 패키지를 포함할 때

- 그걸 방향이 있는 디렉티드 엣지 (directed edge) 라고 해보는거죠.

- 뭔가 보일듯 말듯 하네요. 패키지를 좀 더 많이 설치했다고 해보죠, 이렇게요.

  ```shell
    @package/A
      @package/C
      @package/D

    @package/B
      @package/E
      @package/D

    @package/F
      @package/G
      @package/K

  ```

- 어? 딱 보니까 이거 트리같네요, 그렇죠?

- 적당히 그래프라고 말하는 것보다, 조금 더 말이 되는 소리가 되었습니다.

- 그런데 사실은, 트리 구조라고 표현하기에는 무리가 좀 있습니다.

- 실제로는 이런 경우가 흔하게 있거든요.

  ```shell
    @package/A
      @package/C
      @package/D
        @package/E

    @package/B
      @package/D
        @package/E

    @package/F
      @package/G
      @package/K

  ```

- 이제 무엇처럼 보이시나요?

- 방향이 있는 네트워크 그래프입니다.

- 어.. 그러면 이걸로 또 충분할까요?

- 사실 지금의 예시는, 패키지끼리 서로 참조하는 사이클이 없다고 가정을 한 상태인데요.

- 사이클이 없는, 방향성이 있는 네트워크 그래프라고 할 수 있겠습니다.

- 그런데 여기서 정말, 패키지끼리 사이클이 없을까요?

- 작정하고 만드려고 하면, 만들 수도 있을거같은데 말이죠.

- 실제로 어떨진 모르겠는데, 안될건 없지 않나 싶기도 하구요.

- 일단 저는, 패키지끼리 사이클을 만드려고 시도해 본 적은 없습니다.

- 실제로 가능한지와는 별개로, 사이클 같은건 없다고 생각하시는걸 추천드리겠습니다.

- 일단 여러분이 무언가 하실 때 패키지끼리 사이클이 생긴다면

- 정말 꼭 그래야할지 한 번 생각해보셨으면 좋겠습니다.

- 분명 다른 좋은 방법이 있을거라고 저는 생각합니다.

- 이건 꼭 패키지에만 해당되는 말은 아니구요, 여러분이 파일 분할해서 모듈 구성하실 때도 해당되는 이야기입니다.

- 순환 참조, 사이클이 생긴다?

- 하면, 정말, 정말, 이게 그렇게 밖에 될 수 없는걸까 하고 다시 한 번 생각해보세요.

---

## Reference

- [package-lock.json 은 뭘까요?](https://www.youtube.com/watch?v=P2CtFD6xa54)
